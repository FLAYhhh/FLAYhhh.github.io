<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Postgresql Shared Hash Table | Hao Luan</title> <meta name="author" content="Hao Luan"> <meta name="description" content="A system programmer and resercher's blog. "> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://flayhhh.github.io/blog/2023/PostgreSQL-Shared-Hash-Table/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Hao </span>Luan</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Hao Luan's blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/CV/">CV</a> </li> <li class="nav-item "> <a class="nav-link" href="/Publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/Projects/">Projects</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Postgresql Shared Hash Table</h1> <p class="post-meta">July 12, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/hash"> <i class="fas fa-hashtag fa-sm"></i> Hash,</a>   <a href="/blog/tag/pt-bm"> <i class="fas fa-hashtag fa-sm"></i> PT-BM</a>     ·   <a href="/blog/category/pg"> <i class="fas fa-tag fa-sm"></i> PG</a>   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h2"><a href="#1-%E8%83%8C%E6%99%AF">1. 背景</a></li> <li class="toc-entry toc-h2"> <a href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96">2. 初始化</a> <ul> <li class="toc-entry toc-h3"><a href="#21-%E4%B8%8B%E9%9D%A2%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90shmeminithash%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AD%90%E5%87%BD%E6%95%B0">2.1 下面具体分析ShmemInitHash中使用的子函数:</a></li> <li class="toc-entry toc-h3"><a href="#22-%E5%88%9D%E5%A7%8B%E5%8C%96shmem-data-structure%E7%9A%84%E6%97%B6%E6%9C%BA">2.2 初始化shmem data structure的时机</a></li> </ul> </li> <li class="toc-entry toc-h2"> <a href="#3-%E4%BD%BF%E7%94%A8shmem-data-structure">3. 使用shmem data structure</a> <ul> <li class="toc-entry toc-h3"><a href="#31-hash-search">3.1 hash search</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p><img src="/assets/img/pg_hashtable.png" alt="pg_hashtable.png"></p> <h2 id="1-背景">1. 背景</h2> <p>由于ptbm需要一个集中式的book keeper管理所有文件到虚拟地址的映射, 所以需要将book keeper放在共享内存中. 我们参考pg buffer manager中的hash table熟悉一下在pg中如何实现一个基于共享内存的数据结构.</p> <h2 id="2-初始化">2. 初始化</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ShmemInitHash -- Create and initialize, or attach to, a
 *		shared memory hash table.
 *
 * We assume caller is doing some kind of synchronization
 * so that two processes don't try to create/initialize the same
 * table at once.  (In practice, all creations are done in the postmaster
 * process; child processes should always be attaching to existing tables.)
 *
 * max_size is the estimated maximum number of hashtable entries.  This is
 * not a hard limit, but the access efficiency will degrade if it is
 * exceeded substantially (since it's used to compute directory size and
 * the hash table buckets will get overfull).
 *
 * init_size is the number of hashtable entries to preallocate.  For a table
 * whose maximum size is certain, this should be equal to max_size; that
 * ensures that no run-time out-of-shared-memory failures can occur.
 *
 * *infoP and hash_flags must specify at least the entry sizes and key
 * comparison semantics (see hash_create()).  Flag bits and values specific
 * to shared-memory hash tables are added here, except that callers may
 * choose to specify HASH_PARTITION and/or HASH_FIXED_SIZE.
 *
 * Note: before Postgres 9.0, this function returned NULL for some failure
 * cases.  Now, it always throws error instead, so callers need not check
 * for NULL.
 */</span>
<span class="n">HTAB</span> <span class="o">*</span>
<span class="nf">ShmemInitHash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>		<span class="cm">/* table string name for shmem index */</span>
			  <span class="kt">long</span> <span class="n">init_size</span><span class="p">,</span>	<span class="cm">/* initial table size */</span>
			  <span class="kt">long</span> <span class="n">max_size</span><span class="p">,</span>	<span class="cm">/* max size of the table */</span>
			  <span class="n">HASHCTL</span> <span class="o">*</span><span class="n">infoP</span><span class="p">,</span>	<span class="cm">/* info about key and bucket size */</span>
			  <span class="kt">int</span> <span class="n">hash_flags</span><span class="p">)</span>	<span class="cm">/* info about infoP */</span>
<span class="p">{</span>
	<span class="kt">bool</span>		<span class="n">found</span><span class="p">;</span>
	<span class="kt">void</span>	   <span class="o">*</span><span class="n">location</span><span class="p">;</span>

	<span class="cm">/*
	 * Hash tables allocated in shared memory have a fixed directory; it can't
	 * grow or other backends wouldn't be able to find it. So, make sure we
	 * make it big enough to start with.
	 *
	 * The shared memory allocator must be specified too.
	 */</span>
	<span class="n">infoP</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">infoP</span><span class="o">-&gt;</span><span class="n">max_dsize</span> <span class="o">=</span> <span class="n">hash_select_dirsize</span><span class="p">(</span><span class="n">max_size</span><span class="p">);</span>
	<span class="n">infoP</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">ShmemAllocNoError</span><span class="p">;</span>
	<span class="n">hash_flags</span> <span class="o">|=</span> <span class="n">HASH_SHARED_MEM</span> <span class="o">|</span> <span class="n">HASH_ALLOC</span> <span class="o">|</span> <span class="n">HASH_DIRSIZE</span><span class="p">;</span>

	<span class="cm">/* look it up in the shmem index */</span>
	<span class="n">location</span> <span class="o">=</span> <span class="n">ShmemInitStruct</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
							   <span class="n">hash_get_shared_size</span><span class="p">(</span><span class="n">infoP</span><span class="p">,</span> <span class="n">hash_flags</span><span class="p">),</span>
							   <span class="o">&amp;</span><span class="n">found</span><span class="p">);</span>

	<span class="cm">/*
	 * if it already exists, attach to it rather than allocate and initialize
	 * new space
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
		<span class="n">hash_flags</span> <span class="o">|=</span> <span class="n">HASH_ATTACH</span><span class="p">;</span>

	<span class="cm">/* Pass location of hashtable header to hash_create */</span>
	<span class="n">infoP</span><span class="o">-&gt;</span><span class="n">hctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHHDR</span> <span class="o">*</span><span class="p">)</span> <span class="n">location</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hash_create</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">init_size</span><span class="p">,</span> <span class="n">infoP</span><span class="p">,</span> <span class="n">hash_flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>总结一下初始化阶段的重点:</p> <ul> <li>初始化共享内存data structure可以基于一个假设: postmaster负责初始化, backend只会attach.</li> <li>提供max_size作为预估的内存分配, 运行时超出max_size不会报错, 但是会出现性能下降.</li> <li>info中包含了该hashtable的元信息,例如预估大小、元素分配方法等等.</li> </ul> <h3 id="21-下面具体分析shmeminithash中使用的子函数">2.1 <strong>下面具体分析ShmemInitHash中使用的子函数:</strong> </h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ShmemAllocNoError -- allocate max-aligned chunk from shared memory
 *
 * As ShmemAlloc, but returns NULL if out of space, rather than erroring.
 */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">ShmemAllocNoError</span><span class="p">(</span><span class="n">Size</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Size</span>		<span class="n">allocated_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ShmemAllocRaw</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">allocated_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * ShmemAllocRaw -- allocate align chunk and return allocated size
 *
 * Also sets *allocated_size to the number of bytes allocated, which will
 * be equal to the number requested plus any padding we choose to add.
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">ShmemAllocRaw</span><span class="p">(</span><span class="n">Size</span> <span class="n">size</span><span class="p">,</span> <span class="n">Size</span> <span class="o">*</span><span class="n">allocated_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Size</span>		<span class="n">newStart</span><span class="p">;</span>
	<span class="n">Size</span>		<span class="n">newFree</span><span class="p">;</span>
	<span class="kt">void</span>	   <span class="o">*</span><span class="n">newSpace</span><span class="p">;</span>

	<span class="cm">/*
	 * Ensure all space is adequately aligned.  We used to only MAXALIGN this
	 * space but experience has proved that on modern systems that is not good
	 * enough.  Many parts of the system are very sensitive to critical data
	 * structures getting split across cache line boundaries.  To avoid that,
	 * attempt to align the beginning of the allocation to a cache line
	 * boundary.  The calling code will still need to be careful about how it
	 * uses the allocated space - e.g. by padding each element in an array of
	 * structures out to a power-of-two size - but without this, even that
	 * won't be sufficient.
	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">CACHELINEALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">allocated_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">Assert</span><span class="p">(</span><span class="n">ShmemSegHdr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">SpinLockAcquire</span><span class="p">(</span><span class="n">ShmemLock</span><span class="p">);</span>

	<span class="n">newStart</span> <span class="o">=</span> <span class="n">ShmemSegHdr</span><span class="o">-&gt;</span><span class="n">freeoffset</span><span class="p">;</span>

	<span class="n">newFree</span> <span class="o">=</span> <span class="n">newStart</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newFree</span> <span class="o">&lt;=</span> <span class="n">ShmemSegHdr</span><span class="o">-&gt;</span><span class="n">totalsize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">newSpace</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">ShmemBase</span> <span class="o">+</span> <span class="n">newStart</span><span class="p">);</span>
		<span class="n">ShmemSegHdr</span><span class="o">-&gt;</span><span class="n">freeoffset</span> <span class="o">=</span> <span class="n">newFree</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">newSpace</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">SpinLockRelease</span><span class="p">(</span><span class="n">ShmemLock</span><span class="p">);</span>

	<span class="cm">/* note this assert is okay with newSpace == NULL */</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">newSpace</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">CACHELINEALIGN</span><span class="p">(</span><span class="n">newSpace</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">newSpace</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ===== ShmemSegHdr的定义</span>
<span class="k">static</span> <span class="n">PGShmemHeader</span> <span class="o">*</span><span class="n">ShmemSegHdr</span><span class="p">;</span>	<span class="cm">/* shared mem segment header */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">PGShmemHeader</span>	<span class="cm">/* standard header for all Postgres shmem */</span>
<span class="p">{</span>
	<span class="n">int32</span>		<span class="n">magic</span><span class="p">;</span>			<span class="cm">/* magic # to identify Postgres segments */</span>
<span class="cp">#define PGShmemMagic  679834894
</span>	<span class="n">pid_t</span>		<span class="n">creatorPID</span><span class="p">;</span>		<span class="cm">/* PID of creating process (set but unread) */</span>
	<span class="n">Size</span>		<span class="n">totalsize</span><span class="p">;</span>		<span class="cm">/* total size of segment */</span>
	<span class="n">Size</span>		<span class="n">freeoffset</span><span class="p">;</span>		<span class="cm">/* offset to first free space */</span>
	<span class="n">dsm_handle</span>	<span class="n">dsm_control</span><span class="p">;</span>	<span class="cm">/* ID of dynamic shared memory control seg */</span>
	<span class="kt">void</span>	   <span class="o">*</span><span class="n">index</span><span class="p">;</span>			<span class="cm">/* pointer to ShmemIndex table */</span>
<span class="cp">#ifndef WIN32					</span><span class="cm">/* Windows doesn't have useful inode#s */</span><span class="cp">
</span>	<span class="n">dev_t</span>		<span class="n">device</span><span class="p">;</span>			<span class="cm">/* device data directory is on */</span>
	<span class="n">ino_t</span>		<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* inode number of data directory */</span>
<span class="cp">#endif
</span><span class="p">}</span> <span class="n">PGShmemHeader</span><span class="p">;</span>

<span class="c1">// =======Shmem的初始化</span>
<span class="cm">/*
 *	InitShmemAccess() --- set up basic pointers to shared memory.
 *
 * Note: the argument should be declared "PGShmemHeader *seghdr",
 * but we use void to avoid having to include ipc.h in shmem.h.
 */</span>
<span class="kt">void</span>
<span class="nf">InitShmemAccess</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">seghdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PGShmemHeader</span> <span class="o">*</span><span class="n">shmhdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PGShmemHeader</span> <span class="o">*</span><span class="p">)</span> <span class="n">seghdr</span><span class="p">;</span>

	<span class="n">ShmemSegHdr</span> <span class="o">=</span> <span class="n">shmhdr</span><span class="p">;</span>
	<span class="n">ShmemBase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">shmhdr</span><span class="p">;</span>
	<span class="n">ShmemEnd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">ShmemBase</span> <span class="o">+</span> <span class="n">shmhdr</span><span class="o">-&gt;</span><span class="n">totalsize</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>按照cache line对齐的大小分配</li> <li>空间不足时会返回NULL</li> <li>从ShmemSegHdr中获取当前free address, 顺序向后分配.</li> <li>关于shared memory初始化, 参考:</li> </ul> <p><a href="https://www.notion.so/Postgresql-Shared-memory-797f17811e31459eb12680ea63dadd40?pvs=21" rel="external nofollow noopener" target="_blank">Postgresql Shared memory初始化</a></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Select an appropriate directory size for a hashtable with the given
 * maximum number of entries.
 * This is only needed for hashtables in shared memory, whose directories
 * cannot be expanded dynamically.
 * NB: assumes that all hash structure parameters have default values!
 *
 * XXX this had better agree with the behavior of init_htab()...
 */</span>
<span class="kt">long</span>
<span class="nf">hash_select_dirsize</span><span class="p">(</span><span class="kt">long</span> <span class="n">num_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span>		<span class="n">nBuckets</span><span class="p">,</span>
				<span class="n">nSegments</span><span class="p">,</span>
				<span class="n">nDirEntries</span><span class="p">;</span>

	<span class="cm">/* estimate number of buckets wanted */</span>
	<span class="n">nBuckets</span> <span class="o">=</span> <span class="n">next_pow2_long</span><span class="p">(</span><span class="n">num_entries</span><span class="p">);</span>
	<span class="cm">/* # of segments needed for nBuckets */</span>
	<span class="n">nSegments</span> <span class="o">=</span> <span class="n">next_pow2_long</span><span class="p">((</span><span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEF_SEGSIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* directory entries */</span>
	<span class="n">nDirEntries</span> <span class="o">=</span> <span class="n">DEF_DIRSIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nDirEntries</span> <span class="o">&lt;</span> <span class="n">nSegments</span><span class="p">)</span>
		<span class="n">nDirEntries</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* dir_alloc doubles dsize at each call */</span>

	<span class="k">return</span> <span class="n">nDirEntries</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * Constants
 *
 * A hash table has a top-level "directory", each of whose entries points
 * to a "segment" of ssize bucket headers.  The maximum number of hash
 * buckets is thus dsize * ssize (but dsize may be expansible).  Of course,
 * the number of records in the table can be larger, but we don't want a
 * whole lot of records per bucket or performance goes down.
 *
 * In a hash table allocated in shared memory, the directory cannot be
 * expanded because it must stay at a fixed address.  The directory size
 * should be selected using hash_select_dirsize (and you'd better have
 * a good idea of the maximum number of entries!).  For non-shared hash
 * tables, the initial directory size can be left at the default.
 */</span>
<span class="cp">#define DEF_SEGSIZE			   256
#define DEF_SEGSIZE_SHIFT	   8	</span><span class="cm">/* must be log2(DEF_SEGSIZE) */</span><span class="cp">
#define DEF_DIRSIZE			   256
</span></code></pre></div></div> <ul> <li>entry是hash table的最小单元</li> <li>根据entry计算bucket数量</li> <li>根据bucket计算segment数量 (每个segment中默认有256个bucket)</li> <li>根据segment数量计算directory entries的数量 (疑惑)</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Compute the required initial memory allocation for a shared-memory
 * hashtable with the given parameters.  We need space for the HASHHDR
 * and for the (non expansible) directory.
 */</span>
<span class="n">Size</span>
<span class="nf">hash_get_shared_size</span><span class="p">(</span><span class="n">HASHCTL</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_DIRSIZE</span><span class="p">);</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_dsize</span><span class="p">);</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HASHHDR</span><span class="p">)</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HASHSEGMENT</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>根据info中的dsize和一个HASHSEGMENT的大小计算出整个hashtable需要的空间.</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * hash_create -- create a new dynamic hash table
 *
 *	tabname: a name for the table (for debugging purposes)
 *	nelem: maximum number of elements expected
 *	*info: additional table parameters, as indicated by flags
 *	flags: bitmask indicating which parameters to take from *info
 *
 * The flags value *must* include HASH_ELEM.  (Formerly, this was nominally
 * optional, but the default keysize and entrysize values were useless.)
 * The flags value must also include exactly one of HASH_STRINGS, HASH_BLOBS,
 * or HASH_FUNCTION, to define the key hashing semantics (C strings,
 * binary blobs, or custom, respectively).  Callers specifying a custom
 * hash function will likely also want to use HASH_COMPARE, and perhaps
 * also HASH_KEYCOPY, to control key comparison and copying.
 * Another often-used flag is HASH_CONTEXT, to allocate the hash table
 * under info-&gt;hcxt rather than under TopMemoryContext; the default
 * behavior is only suitable for session-lifespan hash tables.
 * Other flags bits are special-purpose and seldom used, except for those
 * associated with shared-memory hash tables, for which see ShmemInitHash().
 *
 * Fields in *info are read only when the associated flags bit is set.
 * It is not necessary to initialize other fields of *info.
 * Neither tabname nor *info need persist after the hash_create() call.
 *
 * Note: It is deprecated for callers of hash_create() to explicitly specify
 * string_hash, tag_hash, uint32_hash, or oid_hash.  Just set HASH_STRINGS or
 * HASH_BLOBS.  Use HASH_FUNCTION only when you want something other than
 * one of these.
 *
 * Note: for a shared-memory hashtable, nelem needs to be a pretty good
 * estimate, since we can't expand the table on the fly.  But an unshared
 * hashtable can be expanded on-the-fly, so it's better for nelem to be
 * on the small side and let the table grow if it's exceeded.  An overly
 * large nelem will penalize hash_seq_search speed without buying much.
 */</span>
<span class="n">HTAB</span> <span class="o">*</span>
<span class="nf">hash_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tabname</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nelem</span><span class="p">,</span> <span class="k">const</span> <span class="n">HASHCTL</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HTAB</span>	   <span class="o">*</span><span class="n">hashp</span><span class="p">;</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span><span class="p">;</span>

	<span class="cm">/*
	 * Hash tables now allocate space for key and data, but you have to say
	 * how much space to allocate.
	 */</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_ELEM</span><span class="p">);</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">entrysize</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">);</span>

	<span class="cm">/*
	 * For shared hash tables, we have a local hash header (HTAB struct) that
	 * we allocate in TopMemoryContext; all else is in shared memory.
	 *
	 * For non-shared hash tables, everything including the hash header is in
	 * a memory context created specially for the hash table --- this makes
	 * hash_destroy very simple.  The memory context is made a child of either
	 * a context specified by the caller, or TopMemoryContext if nothing is
	 * specified.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Set up to allocate the hash header */</span>
		<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">TopMemoryContext</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/* Create the hash table's private memory context */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_CONTEXT</span><span class="p">)</span>
			<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hcxt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">TopMemoryContext</span><span class="p">;</span>
		<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">AllocSetContextCreate</span><span class="p">(</span><span class="n">CurrentDynaHashCxt</span><span class="p">,</span>
												   <span class="s">"dynahash"</span><span class="p">,</span>
												   <span class="n">ALLOCSET_DEFAULT_SIZES</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the hash header, plus a copy of the table name */</span>
	<span class="n">hashp</span> <span class="o">=</span> <span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="p">)</span> <span class="n">DynaHashAlloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HTAB</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tabname</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">MemSet</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HTAB</span><span class="p">));</span>

	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hashp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span><span class="p">,</span> <span class="n">tabname</span><span class="p">);</span>

	<span class="cm">/* If we have a private context, label it with hashtable's name */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">))</span>
		<span class="n">MemoryContextSetIdentifier</span><span class="p">(</span><span class="n">CurrentDynaHashCxt</span><span class="p">,</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span><span class="p">);</span>

	<span class="cm">/*
	 * Select the appropriate hash function (see comments at head of file).
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_FUNCTION</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HASH_BLOBS</span> <span class="o">|</span> <span class="n">HASH_STRINGS</span><span class="p">)));</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_BLOBS</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_STRINGS</span><span class="p">));</span>
		<span class="cm">/* We can optimize hashing for common key sizes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uint32</span><span class="p">))</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">uint32_hash</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">tag_hash</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * string_hash used to be considered the default hash method, and in a
		 * non-assert build it effectively still is.  But we now consider it
		 * an assertion error to not say HASH_STRINGS explicitly.  To help
		 * catch mistaken usage of HASH_STRINGS, we also insist on a
		 * reasonably long string length: if the keysize is only 4 or 8 bytes,
		 * it's almost certainly an integer or pointer not a string.
		 */</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_STRINGS</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">string_hash</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * If you don't specify a match function, it defaults to string_compare if
	 * you used string_hash, and to memcmp otherwise.
	 *
	 * Note: explicitly specifying string_hash is deprecated, because this
	 * might not work for callers in loadable modules on some platforms due to
	 * referencing a trampoline instead of the string_hash function proper.
	 * Specify HASH_STRINGS instead.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_COMPARE</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">==</span> <span class="n">string_hash</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">HashCompareFunc</span><span class="p">)</span> <span class="n">string_compare</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">;</span>

	<span class="cm">/*
	 * Similarly, the key-copying function defaults to strlcpy or memcpy.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_KEYCOPY</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keycopy</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">keycopy</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">==</span> <span class="n">string_hash</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * The signature of keycopy is meant for memcpy(), which returns
		 * void*, but strlcpy() returns size_t.  Since we never use the return
		 * value of keycopy, and size_t is pretty much always the same size as
		 * void *, this should be safe.  The extra cast in the middle is to
		 * avoid warnings from -Wcast-function-type.
		 */</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keycopy</span> <span class="o">=</span> <span class="p">(</span><span class="n">HashCopyFunc</span><span class="p">)</span> <span class="p">(</span><span class="n">pg_funcptr_t</span><span class="p">)</span> <span class="n">strlcpy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keycopy</span> <span class="o">=</span> <span class="n">memcpy</span><span class="p">;</span>

	<span class="cm">/* And select the entry allocation function, too. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_ALLOC</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">DynaHashAlloc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * ctl structure and directory are preallocated for shared memory
		 * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as
		 * well.
		 */</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHSEGMENT</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HASHHDR</span><span class="p">));</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hcxt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isshared</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/* hash table already exists, we're just attaching to it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_ATTACH</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="cm">/* make local copies of some heavily-used values */</span>
			<span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">;</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">;</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">sshift</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">hashp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/* setup hash table defaults */</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hcxt</span> <span class="o">=</span> <span class="n">CurrentDynaHashCxt</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isshared</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHHDR</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HASHHDR</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">)</span>
			<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
					<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_OUT_OF_MEMORY</span><span class="p">),</span>
					 <span class="n">errmsg</span><span class="p">(</span><span class="s">"out of memory"</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">frozen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">hdefault</span><span class="p">(</span><span class="n">hashp</span><span class="p">);</span>

	<span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_PARTITION</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Doesn't make sense to partition a local hash table */</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">);</span>

		<span class="cm">/*
		 * The number of partitions had better be a power of 2. Also, it must
		 * be less than INT_MAX (see init_htab()), so call the int version of
		 * next_pow2.
		 */</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_partitions</span> <span class="o">==</span> <span class="n">next_pow2_int</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_partitions</span><span class="p">));</span>

		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">num_partitions</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_partitions</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SEGMENT</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">;</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span> <span class="o">=</span> <span class="n">my_log2</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">);</span>
		<span class="cm">/* ssize had better be a power of 2 */</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * SHM hash tables have fixed directory size passed by the caller.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_DIRSIZE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">max_dsize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_dsize</span><span class="p">;</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remember the entry sizes, too */</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">;</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">entrysize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">entrysize</span><span class="p">;</span>

	<span class="cm">/* make local copies of heavily-used constant fields */</span>
	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">;</span>
	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">;</span>
	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">sshift</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">;</span>

	<span class="cm">/* Build the hash directory structure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_htab</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span> <span class="n">nelem</span><span class="p">))</span>
		<span class="n">elog</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">"failed to initialize hash table </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span><span class="p">);</span>

	<span class="cm">/*
	 * For a shared hash table, preallocate the requested number of elements.
	 * This reduces problems with run-time out-of-shared-memory conditions.
	 *
	 * For a non-shared hash table, preallocate the requested number of
	 * elements if it's less than our chosen nelem_alloc.  This avoids wasting
	 * space if the caller correctly estimates a small table size.
	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">nelem</span> <span class="o">&lt;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nelem_alloc</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span>
					<span class="n">freelist_partitions</span><span class="p">,</span>
					<span class="n">nelem_alloc</span><span class="p">,</span>
					<span class="n">nelem_alloc_first</span><span class="p">;</span>

		<span class="cm">/*
		 * If hash table is partitioned, give each freelist an equal share of
		 * the initial allocation.  Otherwise only freeList[0] is used.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">))</span>
			<span class="n">freelist_partitions</span> <span class="o">=</span> <span class="n">NUM_FREELISTS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">freelist_partitions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">nelem_alloc</span> <span class="o">=</span> <span class="n">nelem</span> <span class="o">/</span> <span class="n">freelist_partitions</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nelem_alloc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">nelem_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*
		 * Make sure we'll allocate all the requested elements; freeList[0]
		 * gets the excess if the request isn't divisible by NUM_FREELISTS.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nelem_alloc</span> <span class="o">*</span> <span class="n">freelist_partitions</span> <span class="o">&lt;</span> <span class="n">nelem</span><span class="p">)</span>
			<span class="n">nelem_alloc_first</span> <span class="o">=</span>
				<span class="n">nelem</span> <span class="o">-</span> <span class="n">nelem_alloc</span> <span class="o">*</span> <span class="p">(</span><span class="n">freelist_partitions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">nelem_alloc_first</span> <span class="o">=</span> <span class="n">nelem_alloc</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">freelist_partitions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span>			<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nelem_alloc_first</span> <span class="o">:</span> <span class="n">nelem_alloc</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">element_alloc</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
						<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_OUT_OF_MEMORY</span><span class="p">),</span>
						 <span class="n">errmsg</span><span class="p">(</span><span class="s">"out of memory"</span><span class="p">)));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_FIXED_SIZE</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isfixed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hashp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>hash table有两个重要的头结构:</p> <ul> <li>HTAB (process local)</li> <li>HASHHDR (shmem)</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Top control structure for a hashtable --- in a shared table, each backend
 * has its own copy (OK since no fields change at runtime)
 */</span>
<span class="k">struct</span> <span class="n">HTAB</span>
<span class="p">{</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span><span class="p">;</span>			<span class="cm">/* =&gt; shared control information */</span>
	<span class="n">HASHSEGMENT</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>			<span class="cm">/* directory of segment starts */</span>
	<span class="n">HashValueFunc</span> <span class="n">hash</span><span class="p">;</span>			<span class="cm">/* hash function */</span>
	<span class="n">HashCompareFunc</span> <span class="n">match</span><span class="p">;</span>		<span class="cm">/* key comparison function */</span>
	<span class="n">HashCopyFunc</span> <span class="n">keycopy</span><span class="p">;</span>		<span class="cm">/* key copying function */</span>
	<span class="n">HashAllocFunc</span> <span class="n">alloc</span><span class="p">;</span>		<span class="cm">/* memory allocator */</span>
	<span class="n">MemoryContext</span> <span class="n">hcxt</span><span class="p">;</span>			<span class="cm">/* memory context if default allocator used */</span>
	<span class="kt">char</span>	   <span class="o">*</span><span class="n">tabname</span><span class="p">;</span>		<span class="cm">/* table name (for error messages) */</span>
	<span class="n">bool</span>		<span class="n">isshared</span><span class="p">;</span>		<span class="cm">/* true if table is in shared memory */</span>
	<span class="n">bool</span>		<span class="n">isfixed</span><span class="p">;</span>		<span class="cm">/* if true, don't enlarge */</span>

	<span class="cm">/* freezing a shared table isn't allowed, so we can keep state here */</span>
	<span class="n">bool</span>		<span class="n">frozen</span><span class="p">;</span>			<span class="cm">/* true = no more inserts allowed */</span>

	<span class="cm">/* We keep local copies of these fixed values to reduce contention */</span>
	<span class="n">Size</span>		<span class="n">keysize</span><span class="p">;</span>		<span class="cm">/* hash key length in bytes */</span>
	<span class="kt">long</span>		<span class="n">ssize</span><span class="p">;</span>			<span class="cm">/* segment size --- must be power of 2 */</span>
	<span class="kt">int</span>			<span class="n">sshift</span><span class="p">;</span>			<span class="cm">/* segment shift = log2(ssize) */</span>
<span class="p">};</span>

<span class="cm">/*
 * Header structure for a hash table --- contains all changeable info
 *
 * In a shared-memory hash table, the HASHHDR is in shared memory, while
 * each backend has a local HTAB struct.  For a non-shared table, there isn't
 * any functional difference between HASHHDR and HTAB, but we separate them
 * anyway to share code between shared and non-shared tables.
 */</span>
<span class="k">struct</span> <span class="n">HASHHDR</span>
<span class="p">{</span>
	<span class="cm">/*
	 * The freelist can become a point of contention in high-concurrency hash
	 * tables, so we use an array of freelists, each with its own mutex and
	 * nentries count, instead of just a single one.  Although the freelists
	 * normally operate independently, we will scavenge entries from freelists
	 * other than a hashcode's default freelist when necessary.
	 *
	 * If the hash table is not partitioned, only freeList[0] is used and its
	 * spinlock is not used at all; callers' locking is assumed sufficient.
	 */</span>
	<span class="n">FreeListData</span> <span class="n">freeList</span><span class="p">[</span><span class="n">NUM_FREELISTS</span><span class="p">];</span>

	<span class="cm">/* These fields can change, but not in a partitioned table */</span>
	<span class="cm">/* Also, dsize can't change in a shared table, even if unpartitioned */</span>
	<span class="kt">long</span>		<span class="n">dsize</span><span class="p">;</span>			<span class="cm">/* directory size */</span>
	<span class="kt">long</span>		<span class="n">nsegs</span><span class="p">;</span>			<span class="cm">/* number of allocated segments (&lt;= dsize) */</span>
	<span class="n">uint32</span>		<span class="n">max_bucket</span><span class="p">;</span>		<span class="cm">/* ID of maximum bucket in use */</span>
	<span class="n">uint32</span>		<span class="n">high_mask</span><span class="p">;</span>		<span class="cm">/* mask to modulo into entire table */</span>
	<span class="n">uint32</span>		<span class="n">low_mask</span><span class="p">;</span>		<span class="cm">/* mask to modulo into lower half of table */</span>

	<span class="cm">/* These fields are fixed at hashtable creation */</span>
	<span class="n">Size</span>		<span class="n">keysize</span><span class="p">;</span>		<span class="cm">/* hash key length in bytes */</span>
	<span class="n">Size</span>		<span class="n">entrysize</span><span class="p">;</span>		<span class="cm">/* total user element size in bytes */</span>
	<span class="kt">long</span>		<span class="n">num_partitions</span><span class="p">;</span> <span class="cm">/* # partitions (must be power of 2), or 0 */</span>
	<span class="kt">long</span>		<span class="n">max_dsize</span><span class="p">;</span>		<span class="cm">/* 'dsize' limit if directory is fixed size */</span>
	<span class="kt">long</span>		<span class="n">ssize</span><span class="p">;</span>			<span class="cm">/* segment size --- must be power of 2 */</span>
	<span class="kt">int</span>			<span class="n">sshift</span><span class="p">;</span>			<span class="cm">/* segment shift = log2(ssize) */</span>
	<span class="kt">int</span>			<span class="n">nelem_alloc</span><span class="p">;</span>	<span class="cm">/* number of entries to allocate at once */</span>

<span class="cp">#ifdef HASH_STATISTICS
</span>
	<span class="cm">/*
	 * Count statistics here.  NB: stats code doesn't bother with mutex, so
	 * counts could be corrupted a bit in a partitioned table.
	 */</span>
	<span class="kt">long</span>		<span class="n">accesses</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">collisions</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span>

<span class="cm">/*
 * HASHELEMENT is the private part of a hashtable entry.  The caller's data
 * follows the HASHELEMENT structure (on a MAXALIGN'd boundary).  The hash key
 * is expected to be at the start of the caller's hash entry data structure.
 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">HASHELEMENT</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">HASHELEMENT</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>	<span class="cm">/* link to next entry in same bucket */</span>
	<span class="n">uint32</span>		<span class="n">hashvalue</span><span class="p">;</span>		<span class="cm">/* hash function result for this entry */</span>
<span class="p">}</span> <span class="n">HASHELEMENT</span><span class="p">;</span>
</code></pre></div></div> <p>在hash_create中, 主要做了以下几件事(着重分析共享内存中hash table的初始化):</p> <ul> <li>分配hash header - HTAB</li> <li>初始化 HTAB成员 <ul> <li>哈希表名称</li> <li>哈希函数</li> <li>匹配函数</li> <li>key copy函数</li> <li>元素alloc函数</li> <li>hctl (指向HASSHDR, 即共享内存中的首地址)</li> <li>dir (指向HASSHDR后的空闲地址.)</li> </ul> </li> <li>初始化 HASSHDR成员 <ul> <li>partition数量</li> <li>初始化directory size (存疑)</li> <li>初始化key size, entry size</li> </ul> </li> <li>调用init_htab(hashp, nelem) // nelem: maximum number of elements expected</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Compute derived fields of hctl and build the initial directory/segment
 * arrays
 */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">init_htab</span><span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="n">hashp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nelem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
	<span class="n">HASHSEGMENT</span> <span class="o">*</span><span class="n">segp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nbuckets</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nsegs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="cm">/*
	 * initialize mutexes if it's a partitioned table
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_FREELISTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">SpinLockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mutex</span><span class="p">));</span>

	<span class="cm">/*
	 * Allocate space for the next greater power of two number of buckets,
	 * assuming a desired maximum load factor of 1.
	 */</span>
	<span class="n">nbuckets</span> <span class="o">=</span> <span class="n">next_pow2_int</span><span class="p">(</span><span class="n">nelem</span><span class="p">);</span>

	<span class="cm">/*
	 * In a partitioned table, nbuckets must be at least equal to
	 * num_partitions; were it less, keys with apparently different partition
	 * numbers would map to the same bucket, breaking partition independence.
	 * (Normally nbuckets will be much bigger; this is just a safety check.)
	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nbuckets</span> <span class="o">&lt;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">num_partitions</span><span class="p">)</span>
		<span class="n">nbuckets</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">max_bucket</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">low_mask</span> <span class="o">=</span> <span class="n">nbuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">high_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbuckets</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*
	 * Figure number of directory segments needed, round up to a power of 2
	 */</span>
	<span class="n">nsegs</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">nsegs</span> <span class="o">=</span> <span class="n">next_pow2_int</span><span class="p">(</span><span class="n">nsegs</span><span class="p">);</span>

	<span class="cm">/*
	 * Make sure directory is big enough. If pre-allocated directory is too
	 * small, choke (caller screwed up).
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsegs</span> <span class="o">&gt;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">))</span>
			<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">nsegs</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate a directory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hcxt</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHSEGMENT</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HASHSEGMENT</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate initial segments */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">segp</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nsegs</span> <span class="o">&lt;</span> <span class="n">nsegs</span><span class="p">;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nsegs</span><span class="o">++</span><span class="p">,</span> <span class="n">segp</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="o">*</span><span class="n">segp</span> <span class="o">=</span> <span class="n">seg_alloc</span><span class="p">(</span><span class="n">hashp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">segp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Choose number of entries to allocate at a time */</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nelem_alloc</span> <span class="o">=</span> <span class="n">choose_nelem_alloc</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">entrysize</span><span class="p">);</span>

<span class="cp">#ifdef HASH_DEBUG
</span>	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"init_htab:</span><span class="se">\n</span><span class="s">%s%p</span><span class="se">\n</span><span class="s">%s%ld</span><span class="se">\n</span><span class="s">%s%ld</span><span class="se">\n</span><span class="s">%s%d</span><span class="se">\n</span><span class="s">%s%ld</span><span class="se">\n</span><span class="s">%s%u</span><span class="se">\n</span><span class="s">%s%x</span><span class="se">\n</span><span class="s">%s%x</span><span class="se">\n</span><span class="s">%s%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			<span class="s">"TABLE POINTER   "</span><span class="p">,</span> <span class="n">hashp</span><span class="p">,</span>
			<span class="s">"DIRECTORY SIZE  "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">,</span>
			<span class="s">"SEGMENT SIZE    "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">,</span>
			<span class="s">"SEGMENT SHIFT   "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">,</span>
			<span class="s">"MAX BUCKET      "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">max_bucket</span><span class="p">,</span>
			<span class="s">"HIGH MASK       "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">high_mask</span><span class="p">,</span>
			<span class="s">"LOW  MASK       "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">low_mask</span><span class="p">,</span>
			<span class="s">"NSEGS           "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nsegs</span><span class="p">);</span>
<span class="cp">#endif
</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>初始化freeList[i].mutex</li> <li>初始化nbuckets (每个bucket一个entry)</li> <li>初始化max_bucket, low_mask, high_mask(存疑)</li> <li>计算nsegs(segment数量)</li> <li>分配segment</li> <li>初始化nelem_alloc(一次性分配的元素个数)</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * allocate some new elements and link them into the indicated free list
 */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">element_alloc</span><span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="n">hashp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nelem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">freelist_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
	<span class="n">Size</span>		<span class="n">elementSize</span><span class="p">;</span>
	<span class="n">HASHELEMENT</span> <span class="o">*</span><span class="n">firstElement</span><span class="p">;</span>
	<span class="n">HASHELEMENT</span> <span class="o">*</span><span class="n">tmpElement</span><span class="p">;</span>
	<span class="n">HASHELEMENT</span> <span class="o">*</span><span class="n">prevElement</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isfixed</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Each element has a HASHELEMENT header plus user data. */</span>
	<span class="n">elementSize</span> <span class="o">=</span> <span class="n">MAXALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HASHELEMENT</span><span class="p">))</span> <span class="o">+</span> <span class="n">MAXALIGN</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">entrysize</span><span class="p">);</span>

	<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hcxt</span><span class="p">;</span>
	<span class="n">firstElement</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHELEMENT</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">nelem</span> <span class="o">*</span> <span class="n">elementSize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firstElement</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* prepare to link all the new entries into the freelist */</span>
	<span class="n">prevElement</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tmpElement</span> <span class="o">=</span> <span class="n">firstElement</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nelem</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">tmpElement</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">prevElement</span><span class="p">;</span>
		<span class="n">prevElement</span> <span class="o">=</span> <span class="n">tmpElement</span><span class="p">;</span>
		<span class="n">tmpElement</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHELEMENT</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmpElement</span><span class="p">)</span> <span class="o">+</span> <span class="n">elementSize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if partitioned, must lock to touch freeList */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
		<span class="n">SpinLockAcquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

	<span class="cm">/* freelist could be nonempty if two backends did this concurrently */</span>
	<span class="n">firstElement</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">freeList</span><span class="p">;</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">freeList</span> <span class="o">=</span> <span class="n">prevElement</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
		<span class="n">SpinLockRelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="22-初始化shmem-data-structure的时机">2.2 初始化shmem data structure的时机</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CreateSharedMemoryAndSemaphores</span>
 <span class="o">-</span> <span class="n">InitBufferPool</span>
	<span class="o">-</span> <span class="n">StrategyInitialize</span>
		<span class="o">-</span> <span class="n">InitBufTable</span>
			<span class="o">-</span> <span class="n">ShmemInitHash</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Static</span> <span class="n">HTAB</span> <span class="o">*</span><span class="n">SharedBufHash</span>
</code></pre></div></div> <h2 id="3-使用shmem-data-structure">3. 使用shmem data structure</h2> <p>摘取一段hash_create中的注释:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 <span class="cm">/* For shared hash tables, we have a local hash header (HTAB struct) that
	 we allocate in TopMemoryContext; all else is in shared memory. */</span>
</code></pre></div></div> <p>HTAB(hash 表头)是process local的变量. 所以使用shared hash table的第一步是: 每个backend进程创建HTAB, 并且将HTAB指向共享内存.</p> <p>pg在fork backend进程时, 会在每个backend进程初始化时调用InitBufTable. 而InitBufTable中又调用了ShmemInitHash(). 也就是说每个shared data structure除了需要在postmaster中使用ShmemInitxxx()初始化之外, 还需在backend进程中重新调用ShmemInitxxx()找到共享内存的位置.第一次调用时, pg会在shmem index中创建该数据结构. 第二次调用时, 查找shmem index获取其在shmem中的具体位置.</p> <p>后续得到shared data structure的地址后, 使用对应的访问函数操作即可.</p> <h3 id="31-hash-search">3.1 hash search</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * hash_search -- look up key in table and perform action
 * hash_search_with_hash_value -- same, with key's hash value already computed
 *
 * action is one of:
 *		HASH_FIND: look up key in table
 *		HASH_ENTER: look up key in table, creating entry if not present
 *		HASH_ENTER_NULL: same, but return NULL if out of memory
 *		HASH_REMOVE: look up key in table, remove entry if present
 *
 * Return value is a pointer to the element found/entered/removed if any,
 * or NULL if no match was found.  (NB: in the case of the REMOVE action,
 * the result is a dangling pointer that shouldn't be dereferenced!)
 *
 * HASH_ENTER will normally ereport a generic "out of memory" error if
 * it is unable to create a new entry.  The HASH_ENTER_NULL operation is
 * the same except it will return NULL if out of memory.
 *
 * If foundPtr isn't NULL, then *foundPtr is set true if we found an
 * existing entry in the table, false otherwise.  This is needed in the
 * HASH_ENTER case, but is redundant with the return value otherwise.
 *
 * For hash_search_with_hash_value, the hashvalue parameter must have been
 * calculated with get_hash_value().
 */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">hash_search</span><span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="n">hashp</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">keyPtr</span><span class="p">,</span>
			<span class="n">HASHACTION</span> <span class="n">action</span><span class="p">,</span>
			<span class="n">bool</span> <span class="o">*</span><span class="n">foundPtr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hash_search_with_hash_value</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span>
									   <span class="n">keyPtr</span><span class="p">,</span>
									   <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">(</span><span class="n">keyPtr</span><span class="p">,</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">),</span>
									   <span class="n">action</span><span class="p">,</span>
									   <span class="n">foundPtr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">hash_search_with_hash_value</span><span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="n">hashp</span><span class="p">,</span>
							<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">keyPtr</span><span class="p">,</span>
							<span class="n">uint32</span> <span class="n">hashvalue</span><span class="p">,</span>
							<span class="n">HASHACTION</span> <span class="n">action</span><span class="p">,</span>
							<span class="n">bool</span> <span class="o">*</span><span class="n">foundPtr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">freelist_idx</span> <span class="o">=</span> <span class="n">FREELIST_IDX</span><span class="p">(</span><span class="n">hctl</span><span class="p">,</span> <span class="n">hashvalue</span><span class="p">);</span>
	<span class="n">Size</span>		<span class="n">keysize</span><span class="p">;</span>
	<span class="n">uint32</span>		<span class="n">bucket</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">segment_num</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">segment_ndx</span><span class="p">;</span>
	<span class="n">HASHSEGMENT</span> <span class="n">segp</span><span class="p">;</span>
	<span class="n">HASHBUCKET</span>	<span class="n">currBucket</span><span class="p">;</span>
	<span class="n">HASHBUCKET</span> <span class="o">*</span><span class="n">prevBucketPtr</span><span class="p">;</span>
	<span class="n">HashCompareFunc</span> <span class="n">match</span><span class="p">;</span>

<span class="cp">#ifdef HASH_STATISTICS
</span>	<span class="n">hash_accesses</span><span class="o">++</span><span class="p">;</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">accesses</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif
</span>
	<span class="cm">/*
	 * If inserting, check if it is time to split a bucket.
	 *
	 * NOTE: failure to expand table is not a fatal error, it just means we
	 * have to run at higher fill factor than we wanted.  However, if we're
	 * using the palloc allocator then it will throw error anyway on
	 * out-of-memory, so we must do this before modifying the table.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">HASH_ENTER</span> <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">HASH_ENTER_NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * Can't split if running in partitioned mode, nor if frozen, nor if
		 * table is the subject of any active hash_seq_search scans.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nentries</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">max_bucket</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">frozen</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">has_seq_scans</span><span class="p">(</span><span class="n">hashp</span><span class="p">))</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">expand_table</span><span class="p">(</span><span class="n">hashp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * Do the initial lookup
	 */</span>
	<span class="n">bucket</span> <span class="o">=</span> <span class="n">calc_bucket</span><span class="p">(</span><span class="n">hctl</span><span class="p">,</span> <span class="n">hashvalue</span><span class="p">);</span>

	<span class="n">segment_num</span> <span class="o">=</span> <span class="n">bucket</span> <span class="o">&gt;&gt;</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">;</span>
	<span class="n">segment_ndx</span> <span class="o">=</span> <span class="n">MOD</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">);</span>

	<span class="n">segp</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">[</span><span class="n">segment_num</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">segp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">hash_corrupted</span><span class="p">(</span><span class="n">hashp</span><span class="p">);</span>

	<span class="n">prevBucketPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">segp</span><span class="p">[</span><span class="n">segment_ndx</span><span class="p">];</span>
	<span class="n">currBucket</span> <span class="o">=</span> <span class="o">*</span><span class="n">prevBucketPtr</span><span class="p">;</span>

	<span class="cm">/*
	 * Follow collision chain looking for matching key
	 */</span>
	<span class="n">match</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">;</span>		<span class="cm">/* save one fetch in inner loop */</span>
	<span class="n">keysize</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">;</span>	<span class="cm">/* ditto */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">hashvalue</span> <span class="o">==</span> <span class="n">hashvalue</span> <span class="o">&amp;&amp;</span>
			<span class="n">match</span><span class="p">(</span><span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">),</span> <span class="n">keyPtr</span><span class="p">,</span> <span class="n">keysize</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prevBucketPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">currBucket</span> <span class="o">=</span> <span class="o">*</span><span class="n">prevBucketPtr</span><span class="p">;</span>
<span class="cp">#ifdef HASH_STATISTICS
</span>		<span class="n">hash_collisions</span><span class="o">++</span><span class="p">;</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">collisions</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">foundPtr</span><span class="p">)</span>
		<span class="o">*</span><span class="n">foundPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">bool</span><span class="p">)</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*
	 * OK, now what?
	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="n">HASH_FIND</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">HASH_REMOVE</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/* if partitioned, must lock to touch nentries and freeList */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
					<span class="n">SpinLockAcquire</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">mutex</span><span class="p">));</span>

				<span class="cm">/* delete the record from the appropriate nentries counter. */</span>
				<span class="n">Assert</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">nentries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">nentries</span><span class="o">--</span><span class="p">;</span>

				<span class="cm">/* remove record from hash bucket's chain. */</span>
				<span class="o">*</span><span class="n">prevBucketPtr</span> <span class="o">=</span> <span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

				<span class="cm">/* add the record to the appropriate freelist. */</span>
				<span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">freeList</span><span class="p">;</span>
				<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">freeList</span> <span class="o">=</span> <span class="n">currBucket</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
					<span class="n">SpinLockRelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

				<span class="cm">/*
				 * better hope the caller is synchronizing access to this
				 * element, because someone else is going to reuse it the next
				 * time something is added to the table
				 */</span>
				<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">HASH_ENTER</span><span class="p">:</span>
		<span class="k">case</span> <span class="n">HASH_ENTER_NULL</span><span class="p">:</span>
			<span class="cm">/* Return existing element if found, else create one */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">);</span>

			<span class="cm">/* disallow inserts if frozen */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">frozen</span><span class="p">)</span>
				<span class="n">elog</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">"cannot insert into frozen hashtable </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span>
					 <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span><span class="p">);</span>

			<span class="n">currBucket</span> <span class="o">=</span> <span class="n">get_hash_entry</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span> <span class="n">freelist_idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/* out of memory */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">HASH_ENTER_NULL</span><span class="p">)</span>
					<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="cm">/* report a generic message */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isshared</span><span class="p">)</span>
					<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
							<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_OUT_OF_MEMORY</span><span class="p">),</span>
							 <span class="n">errmsg</span><span class="p">(</span><span class="s">"out of shared memory"</span><span class="p">)));</span>
				<span class="k">else</span>
					<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
							<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_OUT_OF_MEMORY</span><span class="p">),</span>
							 <span class="n">errmsg</span><span class="p">(</span><span class="s">"out of memory"</span><span class="p">)));</span>
			<span class="p">}</span>

			<span class="cm">/* link into hashbucket chain */</span>
			<span class="o">*</span><span class="n">prevBucketPtr</span> <span class="o">=</span> <span class="n">currBucket</span><span class="p">;</span>
			<span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/* copy key into record */</span>
			<span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">hashvalue</span> <span class="o">=</span> <span class="n">hashvalue</span><span class="p">;</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keycopy</span><span class="p">(</span><span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">),</span> <span class="n">keyPtr</span><span class="p">,</span> <span class="n">keysize</span><span class="p">);</span>

			<span class="cm">/*
			 * Caller is expected to fill the data field on return.  DO NOT
			 * insert any code that could possibly throw error here, as doing
			 * so would leave the table entry incomplete and hence corrupt the
			 * caller's data structure.
			 */</span>

			<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">elog</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">"unrecognized hash action code: %d"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">action</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>				<span class="cm">/* keep compiler quiet */</span>
<span class="p">}</span>
</code></pre></div></div> <ol> <li>遇到插入操作时, 决定是否扩容.</li> <li>由哈希值计算应该落入哪一个bucket.</li> </ol> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                  <span class="n">max</span> <span class="n">bucket</span>
<span class="o">|-------------|-----|---------|</span>
          <span class="n">low</span> <span class="n">mask</span><span class="p">.</span>      <span class="n">high</span> <span class="n">mask</span>
</code></pre></div></div> <p>根据max bucket计算出一个二次幂对齐的low mask. high mask是 low mask的两倍. 给定哈希值h, 计算 h bit or high_mask, 计算结果一定在0 - high_mask之间. 如果计算结果小于max_bucket, 则计算结果就是bucket的编号, 否则说明计算结果处于max_bucket - high_mask之间, 此时需要将计算结果和 low_mask做位与, 将bucket偏移到0 - low_mask之间.</p> <ol> <li>根据bucket编号找到对应的bucket, 如果分段, 则需要在分段中寻找bucket</li> <li>find, enter, remove操作都需要首先遍历bucket, 尝试寻找对应的key <ul> <li>find: 找到返回entry, 找不到返回nul</li> <li>enter: 找到返回entry, 找不到从freelist分配entry, 插入bucket链表</li> <li>remove: 找到从bucket链表删除entry, 放回对应的freelist.</li> </ul> </li> </ol> </div> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"flayhhh/flayhhh.github.io","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,a])=>giscusScript.setAttribute(t,a)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Hao Luan. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>