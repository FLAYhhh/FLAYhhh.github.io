<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Source Code Anylysis of Mysql Index Interface | Hao Luan</title> <meta name="author" content="Hao Luan"> <meta name="description" content="This is an old note, I put it here as blog testing purpose."> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://flayhhh.github.io/blog/2022/MySQL-index-interface/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Hao </span>Luan</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Hao Luan's blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/CV/">CV</a> </li> <li class="nav-item "> <a class="nav-link" href="/Publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/Projects/">Projects</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Source Code Anylysis of Mysql Index Interface</h1> <p class="post-meta">October 2, 2022</p> <p class="post-tags"> <a href="/blog/2022"> <i class="fas fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/code-analysis"> <i class="fas fa-hashtag fa-sm"></i> Code-Analysis</a>     ·   <a href="/blog/category/db"> <i class="fas fa-tag fa-sm"></i> DB</a>   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"> <a href="#mysql%E7%B4%A2%E5%BC%95%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">MySQL索引接口源码分析</a> <ul> <li class="toc-entry toc-h2"> <a href="#1-%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA">1. 索引创建</a> <ul> <li class="toc-entry toc-h3"><a href="#create-table%E6%97%B6%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BF%A1%E6%81%AF">create table时,关于索引的信息</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#2-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8">2. 索引使用</a></li> <li class="toc-entry toc-h2"> <a href="#3-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E7%B4%A2%E5%BC%95%E6%8E%A5%E5%8F%A3">3. 存储引擎的索引接口</a> <ul> <li class="toc-entry toc-h3"><a href="#31-%E5%9F%BA%E7%B1%BBhandler%E4%B8%AD%E9%AB%98%E5%B1%82%E6%AC%A1%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%B4%A2%E5%BC%95%E6%8E%A5%E5%8F%A3">3.1. 基类handler中高层次抽象的索引接口.</a></li> <li class="toc-entry toc-h3"><a href="#311-ha_index_init">3.1.1. ha_index_init</a></li> <li class="toc-entry toc-h3"><a href="#312-ha_index_end">3.1.2. ha_index_end</a></li> <li class="toc-entry toc-h3"><a href="#313-ha_read_range_first">3.1.3. ha_read_range_first</a></li> <li class="toc-entry toc-h3"><a href="#314-ha_read_range_next">3.1.4. ha_read_range_next</a></li> <li class="toc-entry toc-h3"><a href="#315-ha_index_read_map">3.1.5. ha_index_read_map</a></li> <li class="toc-entry toc-h3"><a href="#316-ha_index_read_last_map">3.1.6. ha_index_read_last_map</a></li> <li class="toc-entry toc-h3"><a href="#317-ha_index_read_idx_map">3.1.7. ha_index_read_idx_map</a></li> <li class="toc-entry toc-h3"><a href="#318-ha_index_next">3.1.8. ha_index_next</a></li> <li class="toc-entry toc-h3"><a href="#319-ha_index_prev">3.1.9. ha_index_prev</a></li> <li class="toc-entry toc-h3"><a href="#3110-ha_index_first">3.1.10. ha_index_first</a></li> <li class="toc-entry toc-h3"><a href="#3111-ha_index_last">3.1.11. ha_index_last</a></li> <li class="toc-entry toc-h3"><a href="#3112-ha_index_next_same">3.1.12. ha_index_next_same</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#appendix-a-class-key">Appendix A: [class] KEY</a></li> <li class="toc-entry toc-h2"><a href="#appendix-b-class-key_part_info">Appendix B: [class] KEY_PART_INFO</a></li> <li class="toc-entry toc-h2"> <a href="#appendix-c-class-handler%E5%BD%93%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9B%B8%E5%85%B3%E7%9A%84%E6%88%90%E5%91%98">Appendix C: [class] handler当中索引相关的成员</a> <ul> <li class="toc-entry toc-h3"><a href="#1-inited">1. inited</a></li> <li class="toc-entry toc-h3"><a href="#2-end_range">2. end_range</a></li> <li class="toc-entry toc-h3"><a href="#3--m_record_buffer">3. m_record_buffer</a></li> <li class="toc-entry toc-h3"><a href="#4-m_unique">4. m_unique</a></li> <li class="toc-entry toc-h3"><a href="#5-eq_range">5. eq_range</a></li> </ul> </li> <li class="toc-entry toc-h2"><a href="#appendix-d-class-record_buffer">Appendix D: [class] Record_buffer</a></li> <li class="toc-entry toc-h2"><a href="#appendix-e-class-unique_on_insert">Appendix E: [Class] Unique_on_insert</a></li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <h1 id="mysql索引接口源码分析">MySQL索引接口源码分析</h1> <hr> <h2 id="1-索引创建">1. 索引创建</h2> <p>MySQL创建索引的方式有两种：</p> <ul> <li>在create table时创建</li> <li>调用create index创建索引</li> </ul> <p>因此与索引创建对应的存储引擎接口为：</p> <ul> <li>handle::create()</li> <li> </li> </ul> <p>索引创建示例</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="nf">Customer</span><span class="p">(</span>
<span class="n">ID</span> <span class="n">INT</span> <span class="n">NOT</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="n">LastName</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="n">NOT</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="n">FirstName</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="n">NOT</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="n">Email</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="n">NOT</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="n">INDEX</span> <span class="p">(</span><span class="n">Email</span><span class="p">),</span>
<span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div> <h3 id="create-table时关于索引的信息">create table时,关于索引的信息</h3> <p>TABLE::key_info[]</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <p>TABLE_SHARE::primary_key</p> <p>TABLE_SHARE中包含了主键的索引序号</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">901</span>    <span class="cm">/* Primary key index number, used in TABLE::key_info[] */</span>
   <span class="mi">1</span>   <span class="n">uint</span> <span class="n">primary_key</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</code></pre></div></div> <h2 id="2-索引使用">2. 索引使用</h2> <p>通常，索引的使用方式分为两种：点查询和范围查询。为了更好的分析索引的行为和工作流程，我们先从应用层的视角列举一些典型的索引使用场景。</p> <p><strong>使用点查询的SQL语句：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">## where clause中的条件包含索引键的相等判断
</span>
<span class="o">&gt;</span> <span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">table_a</span> \
<span class="o">&gt;</span> <span class="n">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="o">&gt;</span> <span class="n">update</span> <span class="n">table_a</span> \
<span class="o">&gt;</span> <span class="n">set</span> <span class="n">name</span> <span class="o">=</span> <span class="err">'</span><span class="n">foo</span><span class="err">'</span> \
<span class="o">&gt;</span> <span class="n">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div> <p><strong>使用范围查询的SQL语句：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">## where clause中的条件是索引键的范围判断
</span>
<span class="o">&gt;</span> <span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">table_a</span> \
<span class="o">&gt;</span> <span class="n">where</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div> <h2 id="3-存储引擎的索引接口">3. 存储引擎的索引接口</h2> <p>索引与数据存储息息相关，所以索引由存储引擎实现。存储引擎需要提供索引接口供Server层使用。</p> <p>存储引擎当中索引相关的接口为：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">## 基类handler当中索引相关的接口
</span><span class="n">ha_index_init</span><span class="p">()</span>
<span class="n">ha_index_end</span><span class="p">()</span>
<span class="n">ha_read_range_first</span><span class="p">()</span>
<span class="o">|-</span> <span class="n">read_range_first</span><span class="p">()</span>
<span class="n">ha_read_range_next</span><span class="p">()</span>
<span class="o">|-</span> <span class="n">read_range_next</span><span class="p">()</span>
<span class="n">ha_index_read_map</span><span class="p">()</span>
<span class="n">ha_index_read_last_map</span><span class="p">()</span>
<span class="n">ha_index_read_idx_map</span><span class="p">()</span>
<span class="n">ha_index_next</span><span class="p">()</span>
<span class="n">ha_index_prev</span><span class="p">()</span>
<span class="n">ha_index_first</span><span class="p">()</span>
<span class="n">ha_index_last</span><span class="p">()</span>
<span class="n">ha_index_next_same</span><span class="p">()</span>
<span class="n">ha_index_or_rnd_end</span><span class="p">()</span>

<span class="cp">## 子类需要具体实现的索引接口（handler中索引相关的虚函数）
</span><span class="n">index_read_map</span><span class="p">()</span>
<span class="n">index_read</span><span class="p">()</span>
<span class="n">index_read_last_map</span><span class="p">()</span>
<span class="n">index_read_last</span><span class="p">()</span>
<span class="n">index_read_idx_map</span><span class="p">()</span>
<span class="n">index_next</span><span class="p">()</span>
<span class="n">index_prev</span><span class="p">()</span>
<span class="n">index_first</span><span class="p">()</span>
<span class="n">index_last</span><span class="p">()</span>
<span class="n">index_next_same</span><span class="p">()</span>
<span class="n">read_range_first</span><span class="p">()</span>
<span class="n">read_range_next</span><span class="p">()</span>
</code></pre></div></div> <h3 id="31-基类handler中高层次抽象的索引接口">3.1. 基类handler中高层次抽象的索引接口.</h3> <p>先具体分析基类handler中实现的索引相关接口.</p> <h3 id="311-ha_index_init">3.1.1. ha_index_init</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  Initialize use of index.

  @param idx     Index to use
  @param sorted  Use sorted order

  @return Operation status
    @retval 0     Success
    @retval != 0  Error (error code returned)
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_init</span><span class="p">(</span><span class="n">uint</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="n">index_init</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sorted</span><span class="p">)))</span> <span class="n">inited</span> <span class="o">=</span> <span class="n">INDEX</span><span class="p">;</span>
  <span class="n">end_range</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以看到ha_index_init主要将索引的初始化工作交给了子类的index_init.除此之外, ha_index_init设置了两个状态变量:</p> <ul> <li>inited</li> </ul> <p>见Appendix C.1, 表示table的使用方式.</p> <ul> <li>end_range</li> </ul> <p>见Appendix C.2, 表示范围查询的边界.</p> <h3 id="312-ha_index_end">3.1.2. ha_index_end</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  End use of index.

  @return Operation status
    @retval 0     Success
    @retval != 0  Error (error code returned)
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_end</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">inited</span> <span class="o">=</span> <span class="n">NONE</span><span class="p">;</span>
  <span class="n">end_range</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="n">m_record_buffer</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m_unique</span><span class="p">)</span> <span class="n">m_unique</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">index_end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>ha_index_end()在调用index_end()之前做了一些额外工作:</p> <ul> <li>将inited设置为NONE</li> <li>将end_range设置为nullptr</li> <li>将m_record_buffer设置为nullptr</li> </ul> <p>见Appendix C.3, m_record_buffer是用于存放读取结果的缓存.</p> <ul> <li>重置m_unique</li> </ul> <p>见Appendix C.4, m_unique用于检测集合中的重复值.</p> <h3 id="313-ha_read_range_first">3.1.3. ha_read_range_first</h3> <p>ha_read_range_first()给定start key和 end key, 读取范围内的第一个row, 并设置好范围的终点, 供后续的ha_read_range_next()使用.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_read_range_first</span><span class="p">(</span><span class="k">const</span> <span class="n">key_range</span> <span class="o">*</span><span class="n">start_key</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">key_range</span> <span class="o">*</span><span class="n">end_key</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eq_range</span><span class="p">,</span>
                                 <span class="kt">bool</span> <span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">read_range_first</span><span class="p">(</span><span class="n">start_key</span><span class="p">,</span> <span class="n">end_key</span><span class="p">,</span> <span class="n">eq_range</span><span class="p">,</span> <span class="n">sorted</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>ha_read_range_first()的主要工作由read_range_first()完成:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @brief
  Read first row between two ranges.
  Store ranges for future calls to read_range_next.

  @param start_key		Start key. Is 0 if no min range
  @param end_key		End key.  Is 0 if no max range
  @param eq_range_arg	        Set to 1 if start_key == end_key
  @param sorted		Set to 1 if result should be sorted per key

  @note
    Record is read into table-&gt;record[0]

  @retval
    0			Found row
  @retval
    HA_ERR_END_OF_FILE	No rows in range
*/</span>
<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">read_range_first</span><span class="p">(</span><span class="k">const</span> <span class="n">key_range</span> <span class="o">*</span><span class="n">start_key</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">key_range</span> <span class="o">*</span><span class="n">end_key</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eq_range_arg</span><span class="p">,</span>
                              <span class="kt">bool</span> <span class="n">sorted</span> <span class="nf">MY_ATTRIBUTE</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">eq_range</span> <span class="o">=</span> <span class="n">eq_range_arg</span><span class="p">;</span>
  <span class="n">set_end_range</span><span class="p">(</span><span class="n">end_key</span><span class="p">,</span> <span class="n">RANGE_SCAN_ASC</span><span class="p">);</span>

  <span class="n">range_key_part</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">key_info</span><span class="p">[</span><span class="n">active_index</span><span class="p">].</span><span class="n">key_part</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_key</span><span class="p">)</span>  <span class="c1">// Read first record</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ha_index_first</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="k">else</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ha_index_read_map</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start_key</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
                               <span class="n">start_key</span><span class="o">-&gt;</span><span class="n">keypart_map</span><span class="p">,</span> <span class="n">start_key</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">HA_ERR_KEY_NOT_FOUND</span><span class="p">)</span> <span class="o">?</span> <span class="n">HA_ERR_END_OF_FILE</span> <span class="o">:</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">compare_key</span><span class="p">(</span><span class="n">end_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*
      The last read row does not fall in the range. So request
      storage engine to release row lock if possible.
    */</span>
    <span class="n">unlock_row</span><span class="p">();</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">HA_ERR_END_OF_FILE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>read_range_first()函数读取了范围查询当中的第一行.</p> <p>具体实现中有一些值得注意的点:</p> <ul> <li>eq_range的设置, 见Appendix C.5</li> </ul> <p>eq_range为true时,表示范围内的所有key都必须相等.</p> <ul> <li>set_end_range(end_key, RANGE_SCAN_ASC); 见Appendix C.2</li> </ul> <p>将end_key的信息和搜索方向记录到handler中.</p> <ul> <li>ha_index_first()读取索引顺序为1的行.</li> <li>ha_index_read_map()根据key进行索引搜索,这里根据start key找到第一条符合start key的记录.</li> </ul> <h3 id="314-ha_read_range_next">3.1.4. ha_read_range_next</h3> <p>server层进行范围查询时,使用ha_read_range_first定位起始key, 随后, handler中应该维护着索引当前指向的key以及对应的记录.ha_read_range_next()读取范围搜索中的下一条记录. 主要工作由read_range_next()函数完成.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_read_range_next</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">read_range_next</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @brief
  Read next row between two endpoints.

  @note
    Record is read into table-&gt;record[0]

  @retval
    0			Found row
  @retval
    HA_ERR_END_OF_FILE	No rows in range
*/</span>
<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">read_range_next</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DBUG_TRACE</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">eq_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* We trust that index_next_same always gives a row in range */</span>
    <span class="n">result</span> <span class="o">=</span>
        <span class="n">ha_index_next_same</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_range</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">end_range</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ha_index_next</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">compare_key</span><span class="p">(</span><span class="n">end_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/*
        The last read row does not fall in the range. So request
        storage engine to release row lock if possible.
      */</span>
      <span class="n">unlock_row</span><span class="p">();</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">HA_ERR_END_OF_FILE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="315-ha_index_read_map">3.1.5. ha_index_read_map</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  Read [part of] row via [part of] index.
  @param[out] buf          buffer where store the data
  @param      key          Key to search for
  @param      keypart_map  Which part of key to use
  @param      find_flag    Direction/condition on key usage

  @returns Operation status
    @retval  0                   Success (found a record, and function has
                                 set table status to "has row")
    @retval  HA_ERR_END_OF_FILE  Row not found (function has set table status
                                 to "no row"). End of index passed.
    @retval  HA_ERR_KEY_NOT_FOUND Row not found (function has set table status
                                 to "no row"). Index cursor positioned.
    @retval  != 0                Error

  @note Positions an index cursor to the index specified in the handle.
  Fetches the row if available. If the key value is null,
  begin at the first key of the index.
  ha_index_read_map can be restarted without calling index_end on the previous
  index scan and without calling ha_index_init. In this case the
  ha_index_read_map is on the same index as the previous ha_index_scan.
  This is particularly used in conjunction with multi read ranges.
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_read_map</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                               <span class="n">key_part_map</span> <span class="n">keypart_map</span><span class="p">,</span>
                               <span class="k">enum</span> <span class="n">ha_rkey_function</span> <span class="n">find_flag</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MYSQL_TABLE_IO_WAIT</span><span class="p">(</span><span class="n">PSI_TABLE_FETCH_ROW</span><span class="p">,</span> <span class="n">active_index</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">index_read_map</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keypart_map</span><span class="p">,</span> <span class="n">find_flag</span><span class="p">);</span>
  <span class="p">})</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>ha_index_read_map的语义是根据key进行索引搜索,读取结果存放到buf中.</p> <p><strong>key_part_map类型</strong></p> <p>key_part_map的类型为unsigned long。</p> <p>key_part_map是指，‘key中的列’与‘该列是否参与索引的搜索’之间的映射。例如我的索引key由四个column组成，按照这些索引列在schema中的顺序列举：key_part_a, key_part_b, key_part_c, key_part_d。对应的key_part_map实际上只需要四个bit，我们将key_part_map中低位的bit对应到schema中考前的column，key_part_map中bit为1时，说明该索引列参与索引。这样，key_part_map为1111就说明所有的索引列都参与索引。而0011则说明采用只采用key_part_a和key_part_b进行索引，即key_part_a和key_part_b组成的前缀索引。</p> <p><strong>enum ha_rkey_function类型</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">ha_rkey_function</span>
<span class="n">type</span> <span class="o">=</span> <span class="k">enum</span> <span class="n">ha_rkey_function</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span><span class="n">HA_READ_KEY_EXACT</span><span class="p">,</span> <span class="n">HA_READ_KEY_OR_NEXT</span><span class="p">,</span> <span class="n">HA_READ_KEY_OR_PREV</span><span class="p">,</span> <span class="n">HA_READ_AFTER_KEY</span><span class="p">,</span> <span class="n">HA_READ_BEFORE_KEY</span><span class="p">,</span> <span class="n">HA_READ_PREFIX</span><span class="p">,</span>
    <span class="n">HA_READ_PREFIX_LAST</span><span class="p">,</span> <span class="n">HA_READ_PREFIX_LAST_OR_PREV</span><span class="p">,</span> <span class="n">HA_READ_MBR_CONTAIN</span><span class="p">,</span> <span class="n">HA_READ_MBR_INTERSECT</span><span class="p">,</span> <span class="n">HA_READ_MBR_WITHIN</span><span class="p">,</span> <span class="n">HA_READ_MBR_DISJOINT</span><span class="p">,</span>
    <span class="n">HA_READ_MBR_EQUAL</span><span class="p">,</span> <span class="n">HA_READ_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
</code></pre></div></div> <h3 id="316-ha_index_read_last_map">3.1.6. ha_index_read_last_map</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ha_index_read_last_map</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                             <span class="n">key_part_map</span> <span class="n">keypart_map</span><span class="p">);</span>

<span class="cp">## 具体实现随着存储引擎的不同而变化,在index_read_last_map中实现.
</span></code></pre></div></div> <p>ha_index_read_last_map的行为和ha_index_read_map类似.唯一的区别在于,该函数读取的符合条件的最后一条记录.</p> <h3 id="317-ha_index_read_idx_map">3.1.7. ha_index_read_idx_map</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  Initializes an index and read it.

  @see handler::ha_index_read_map.
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_read_idx_map</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                                   <span class="n">key_part_map</span> <span class="n">keypart_map</span><span class="p">,</span>
                                   <span class="k">enum</span> <span class="n">ha_rkey_function</span> <span class="n">find_flag</span><span class="p">);</span>
</code></pre></div></div> <p>行为和ha_index_read_map类似,唯一的区别在于显式的指定使用的索引.</p> <h3 id="318-ha_index_next">3.1.8. ha_index_next</h3> <p>ha_index_next读取索引中的下一条记录.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  Reads the next row via index.

  @param[out] buf  Row data

  @return Operation status.
    @retval  0                   Success
    @retval  HA_ERR_END_OF_FILE  Row not found
    @retval  != 0                Error
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_next</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MYSQL_TABLE_IO_WAIT</span><span class="p">(</span><span class="n">PSI_TABLE_FETCH_ROW</span><span class="p">,</span> <span class="n">active_index</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
                      <span class="p">{</span> <span class="n">result</span> <span class="o">=</span> <span class="n">index_next</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="p">})</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="319-ha_index_prev">3.1.9. ha_index_prev</h3> <p>读取索引中的前一条记录</p> <h3 id="3110-ha_index_first">3.1.10. ha_index_first</h3> <p>读取索引的第一条记录</p> <h3 id="3111-ha_index_last">3.1.11. ha_index_last</h3> <p>读取索引的最后一条记录</p> <h3 id="3112-ha_index_next_same">3.1.12. ha_index_next_same</h3> <p>读取下一条key相同的记录</p> <hr> <h2 id="appendix-a-class-key">Appendix A: [class] KEY</h2> <p>index key的元数据 </p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">type</span> <span class="o">=</span> <span class="k">class</span> <span class="nc">KEY</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">uint</span> <span class="n">key_length</span><span class="p">;</span>
    <span class="n">ulong</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">ulong</span> <span class="n">actual_flags</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">user_defined_key_parts</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">actual_key_parts</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">unused_key_parts</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">usable_key_parts</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">block_size</span><span class="p">;</span>
    <span class="n">ha_key_alg</span> <span class="n">algorithm</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">is_algorithm_explicit</span><span class="p">;</span>
    <span class="n">plugin_ref</span> <span class="n">parser</span><span class="p">;</span>
    <span class="n">LEX_CSTRING</span> <span class="n">parser_name</span><span class="p">;</span>
    <span class="n">KEY_PART_INFO</span> <span class="o">*</span><span class="n">key_part</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">ulong</span> <span class="o">*</span><span class="n">rec_per_key</span><span class="p">;</span>
    <span class="n">LEX_CSTRING</span> <span class="n">engine_attribute</span><span class="p">;</span>
    <span class="n">LEX_CSTRING</span> <span class="n">secondary_engine_attribute</span><span class="p">;</span>
  <span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">m_in_memory_estimate</span><span class="p">;</span>
    <span class="n">rec_per_key_t</span> <span class="o">*</span><span class="n">rec_per_key_float</span><span class="p">;</span>
  <span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">is_visible</span><span class="p">;</span>
    <span class="n">TABLE</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
    <span class="n">LEX_CSTRING</span> <span class="n">comment</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">is_functional_index</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">has_records_per_key</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">rec_per_key_t</span> <span class="n">records_per_key</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">set_records_per_key</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="n">rec_per_key_t</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">supports_records_per_key</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">set_rec_per_key_array</span><span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">,</span> <span class="n">rec_per_key_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">in_memory_estimate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">set_in_memory_estimate</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="appendix-b-class-key_part_info">Appendix B: [class] KEY_PART_INFO</h2> <p>index key中每个key part的元数据</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">KEY_PART_INFO</span>
<span class="n">type</span> <span class="o">=</span> <span class="k">class</span> <span class="nc">KEY_PART_INFO</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">Field</span> <span class="o">*</span><span class="n">field</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">null_offset</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">store_length</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">fieldnr</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">key_part_flag</span><span class="p">;</span>
    <span class="n">uint8</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">uint8</span> <span class="n">null_bit</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">bin_cmp</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">init_from_field</span><span class="p">(</span><span class="n">Field</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">init_flags</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="appendix-c-class-handler当中索引相关的成员">Appendix C: [class] handler当中索引相关的成员</h2> <h3 id="1-inited">1. inited</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="p">{</span> <span class="n">NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">INDEX</span><span class="p">,</span> <span class="n">RND</span><span class="p">,</span> <span class="n">SAMPLING</span> <span class="p">}</span> <span class="n">inited</span><span class="p">;</span>
</code></pre></div></div> <p>[猜测]</p> <p>inited表示server层通过handler使用table的方式.</p> <p>例如当使用索引操作table时,inited的值为INDEX.</p> <h3 id="2-end_range">2. end_range</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
    End value for a range scan. If this is NULL the range scan has no
    end value. Should also be NULL when there is no ongoing range scan.
    Used by the read_range() functions and also evaluated by pushed
    index conditions.
  */</span>
  <span class="n">key_range</span> <span class="o">*</span><span class="n">end_range</span><span class="p">;</span>
</code></pre></div></div> <p>在范围查询时标记着结束的边界值.</p> <p>key_range的类型为:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">key_range</span>
<span class="n">type</span> <span class="o">=</span> <span class="k">struct</span> <span class="nc">key_range</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">key_part_map</span> <span class="n">keypart_map</span><span class="p">;</span>
    <span class="n">ha_rkey_function</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">## 由于key中的组成部分可能不会全部使用,结束边界以及判定方法也依赖于调用时的情况,
## 所以需要key_range这一类型表达范围查询的边界.
</span></code></pre></div></div> <h3 id="3--m_record_buffer">3. m_record_buffer</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Record_buffer</span> <span class="o">*</span><span class="n">m_record_buffer</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">///&lt; Buffer for multi-row reads.</span>
</code></pre></div></div> <p>如注释所述,当server层通过handler读取table中的数据超过一行时,结果存放在m_record_buffer中.</p> <p>[class] Record_buffer见Appendix D.</p> <h3 id="4-m_unique">4. m_unique</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Filter row ids to weed out duplicates when multi-valued index is used */</span>
  <span class="n">Unique_on_insert</span> <span class="o">*</span><span class="n">m_unique</span><span class="p">;</span>
</code></pre></div></div> <p>[class] Unique_on_insert见 Appendix E.</p> <h3 id="5-eq_range">5. eq_range</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">eq_range</span>
</code></pre></div></div> <p>eq_range为true时,范围内的key值需要相等.</p> <h2 id="appendix-d-class-record_buffer">Appendix D: [class] Record_buffer</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  This class represents a buffer that can be used for multi-row reads. It is
  allocated by the executor and given to the storage engine through the
  handler, using handler::ha_set_record_buffer(), so that the storage engine
  can fill the buffer with multiple rows in a single read call.

  For now, the record buffer is only used internally by the storage engine as
  a prefetch cache. The storage engine fills the record buffer when the
  executor requests the first record, but it returns a single record only to
  the executor. If the executor wants to access the records in the buffer, it
  has to call a handler function such as handler::ha_index_next() or
  handler::ha_rnd_next(). Then the storage engine will copy the next record
  from the record buffer to the memory area specified in the arguments of the
  handler function, typically TABLE::record[0].
*/</span>
<span class="k">class</span> <span class="nc">Record_buffer</span> <span class="p">{</span>
  <span class="c1">/// The maximum number of records that can be stored in the buffer.</span>
  <span class="n">ha_rows</span> <span class="n">m_max_records</span><span class="p">;</span>
  <span class="c1">/// The number of bytes available for each record.</span>
  <span class="kt">size_t</span> <span class="n">m_record_size</span><span class="p">;</span>
  <span class="c1">/// The number of records currently stored in the buffer.</span>
  <span class="n">ha_rows</span> <span class="n">m_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// The @c uchar buffer that holds the records.</span>
  <span class="n">uchar</span> <span class="o">*</span><span class="n">m_buffer</span><span class="p">;</span>
  <span class="c1">/// Tells if end-of-range was found while filling the buffer.</span>
  <span class="kt">bool</span> <span class="n">m_out_of_range</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

 <span class="nl">public:</span>
  <span class="cm">/**
    Create a new record buffer with the specified size.

    @param records      the number of records that can be stored in the buffer
    @param record_size  the size of each record
    @param buffer       the @c uchar buffer that will hold the records (its
                        size should be at least
                        `Record_buffer::buffer_size(records, record_size)`)
  */</span>
  <span class="n">Record_buffer</span><span class="p">(</span><span class="n">ha_rows</span> <span class="n">records</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">record_size</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">m_max_records</span><span class="p">(</span><span class="n">records</span><span class="p">),</span> <span class="n">m_record_size</span><span class="p">(</span><span class="n">record_size</span><span class="p">),</span> <span class="n">m_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{}</span>

  <span class="cm">/**
    This function calculates how big the @c uchar buffer provided to
    Record_buffer's constructor must be, given a number of records and
    the record size.

    @param records      the maximum number of records in the buffer
    @param record_size  the size of each record
    @return the total number of bytes needed for all the records
  */</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">buffer_size</span><span class="p">(</span><span class="n">ha_rows</span> <span class="n">records</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">record_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">records</span> <span class="o">*</span> <span class="n">record_size</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**
    Get the number of records that can be stored in the buffer.
    @return the maximum number of records in the buffer
  */</span>
  <span class="n">ha_rows</span> <span class="n">max_records</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_max_records</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Get the amount of space allocated for each record in the buffer.
    @return the record size
  */</span>
  <span class="kt">size_t</span> <span class="n">record_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_record_size</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Get the number of records currently stored in the buffer.
    @return the number of records stored in the buffer
  */</span>
  <span class="n">ha_rows</span> <span class="n">records</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_count</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Get the buffer that holds the record on position @a pos.
    @param pos the record number (must be smaller than records())
    @return the @c uchar buffer that holds the specified record
  */</span>
  <span class="n">uchar</span> <span class="o">*</span><span class="nf">record</span><span class="p">(</span><span class="n">ha_rows</span> <span class="n">pos</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">max_records</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">m_buffer</span> <span class="o">+</span> <span class="n">m_record_size</span> <span class="o">*</span> <span class="n">pos</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**
    Add a new record at the end of the buffer.
    @return the @c uchar buffer of the added record
  */</span>
  <span class="n">uchar</span> <span class="o">*</span><span class="nf">add_record</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m_count</span> <span class="o">&lt;</span> <span class="n">max_records</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">record</span><span class="p">(</span><span class="n">m_count</span><span class="o">++</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**
    Remove the record that was last added to the buffer.
  */</span>
  <span class="kt">void</span> <span class="nf">remove_last</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="o">--</span><span class="n">m_count</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**
    Clear the buffer. Remove all the records. The end-of-range flag is
    preserved.
  */</span>
  <span class="kt">void</span> <span class="nf">clear</span><span class="p">()</span> <span class="p">{</span> <span class="n">m_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Reset the buffer. Remove all records and clear the end-of-range flag.
  */</span>
  <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">m_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">set_out_of_range</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**
    Set whether the end of the range was reached while filling the buffer.
    @param val true if end of range was reached, false if still within range
  */</span>
  <span class="kt">void</span> <span class="nf">set_out_of_range</span><span class="p">(</span><span class="kt">bool</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_out_of_range</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Check if the end of the range was reached while filling the buffer.
    @retval true if the end range was reached
    @retval false if the scan is still within the range
  */</span>
  <span class="kt">bool</span> <span class="n">is_out_of_range</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_out_of_range</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="appendix-e-class-unique_on_insert">Appendix E: [Class] Unique_on_insert</h2> <p>简单地概括,Unique_on_insert是一个检测集合中是否存在重复值的过滤器.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">## 与Unique_on_insert一同定义的还有Class Unique,这里也一并看一下Unique的定义.
</span>
<span class="cm">/**
   Unique -- class for unique (removing of duplicates).
   Puts all values to the TREE. If the tree becomes too big,
   it's dumped to the file. User can request sorted values, or
   just iterate through them. In the last case tree merging is performed in
   memory simultaneously with iteration, so it should be ~2-3x faster.

   Unique values can be read only from final result (not on insert) because
   duplicate values can be contained in different dumped tree files.
*/</span>

<span class="k">class</span> <span class="nc">Unique</span> <span class="p">{</span>
  <span class="c1">/// Array of file pointers</span>
  <span class="n">Prealloced_array</span><span class="o">&lt;</span><span class="n">Merge_chunk</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">file_ptrs</span><span class="p">;</span>
  <span class="c1">/// Max elements in memory buffer</span>
  <span class="n">ulong</span> <span class="n">max_elements</span><span class="p">;</span>
  <span class="c1">/// Memory buffer size</span>
  <span class="n">ulonglong</span> <span class="n">max_in_memory_size</span><span class="p">;</span>
  <span class="c1">/// Cache file for unique values retrieval fo table read AM in executor</span>
  <span class="n">IO_CACHE</span> <span class="n">file</span><span class="p">;</span>
  <span class="c1">/// Tree to filter duplicates in memory</span>
  <span class="n">TREE</span> <span class="n">tree</span><span class="p">;</span>
  <span class="n">uchar</span> <span class="o">*</span><span class="n">record_pointers</span><span class="p">;</span>
  <span class="c1">/// Flush tree to disk</span>
  <span class="kt">bool</span> <span class="n">flush</span><span class="p">();</span>
  <span class="c1">/// Element size</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>

 <span class="nl">public:</span>
  <span class="n">ulong</span> <span class="n">elements</span><span class="p">;</span>
  <span class="n">Unique</span><span class="p">(</span><span class="n">qsort2_cmp</span> <span class="n">comp_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">comp_func_fixed_arg</span><span class="p">,</span> <span class="n">uint</span> <span class="n">size_arg</span><span class="p">,</span>
         <span class="n">ulonglong</span> <span class="n">max_in_memory_size_arg</span><span class="p">);</span>
  <span class="o">~</span><span class="n">Unique</span><span class="p">();</span>
  <span class="n">ulong</span> <span class="n">elements_in_tree</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">tree</span><span class="p">.</span><span class="n">elements_in_tree</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Add new value to Unique

    @details The value is inserted either to the tree, or to the duplicate
    weedout table, depending on the mode of operation. If tree's mem buffer is
    full, it's flushed to the disk.

    @param ptr  pointer to the binary string to insert

    @returns
      false  error or duplicate
      true   the value was inserted
  */</span>
  <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">unique_add</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DBUG_TRACE</span><span class="p">;</span>
    <span class="n">DBUG_PRINT</span><span class="p">(</span><span class="s">"info"</span><span class="p">,</span> <span class="p">(</span><span class="s">"tree %u - %lu"</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">elements_in_tree</span><span class="p">,</span> <span class="n">max_elements</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">elements_in_tree</span> <span class="o">&gt;</span> <span class="n">max_elements</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span><span class="p">())</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">custom_arg</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">get</span><span class="p">(</span><span class="n">TABLE</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>

  <span class="k">typedef</span> <span class="n">Bounds_checked_array</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span> <span class="n">Imerge_cost_buf_type</span><span class="p">;</span>

  <span class="k">static</span> <span class="kt">double</span> <span class="nf">get_use_cost</span><span class="p">(</span><span class="n">Imerge_cost_buf_type</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">uint</span> <span class="n">nkeys</span><span class="p">,</span>
                             <span class="n">uint</span> <span class="n">key_size</span><span class="p">,</span> <span class="n">ulonglong</span> <span class="n">max_in_memory_size</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Cost_model_table</span> <span class="o">*</span><span class="n">cost_model</span><span class="p">);</span>

  <span class="c1">// Returns the number of elements needed in Imerge_cost_buf_type.</span>
  <span class="kr">inline</span> <span class="k">static</span> <span class="kt">size_t</span> <span class="nf">get_cost_calc_buff_size</span><span class="p">(</span><span class="n">ulong</span> <span class="n">nkeys</span><span class="p">,</span> <span class="n">uint</span> <span class="n">key_size</span><span class="p">,</span>
                                               <span class="n">ulonglong</span> <span class="n">max_in_memory_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ulonglong</span> <span class="n">max_elems_in_tree</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">max_in_memory_size</span> <span class="o">/</span> <span class="n">ALIGN_SIZE</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TREE_ELEMENT</span><span class="p">)</span> <span class="o">+</span> <span class="n">key_size</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nkeys</span> <span class="o">/</span> <span class="n">max_elems_in_tree</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">reset</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">walk</span><span class="p">(</span><span class="n">tree_walk_action</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">walk_action_arg</span><span class="p">);</span>

  <span class="n">uint</span> <span class="n">get_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ulonglong</span> <span class="n">get_max_in_memory_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">max_in_memory_size</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">is_in_memory</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">friend</span> <span class="kt">int</span> <span class="nf">unique_write_to_file</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v_key</span><span class="p">,</span> <span class="n">element_count</span> <span class="n">count</span><span class="p">,</span>
                                  <span class="kt">void</span> <span class="o">*</span><span class="n">unique</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">int</span> <span class="nf">unique_write_to_ptrs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v_key</span><span class="p">,</span> <span class="n">element_count</span> <span class="n">count</span><span class="p">,</span>
                                  <span class="kt">void</span> <span class="o">*</span><span class="n">unique</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**
  Unique_on_insert -- similar to above, but rejects duplicates on insert, not
  just on read of the final result.
  To achieve this values are inserted into mem tmp table which uses index to
  detect duplicate keys. When memory buffer is full, tmp table is dumped to a
  disk-based tmp table.
*/</span>

<span class="k">class</span> <span class="nc">Unique_on_insert</span> <span class="p">{</span>
  <span class="c1">/// Element size</span>
  <span class="n">uint</span> <span class="n">m_size</span><span class="p">;</span>
  <span class="c1">/// Duplicate weedout tmp table</span>
  <span class="n">TABLE</span> <span class="o">*</span><span class="n">m_table</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Unique_on_insert</span><span class="p">(</span><span class="n">uint</span> <span class="n">size</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{}</span>
  <span class="cm">/**
    Add row id to the filter

    @param ptr pointer to the rowid

    @returns
      false  rowid successfully inserted
      true   duplicate or error
  */</span>
  <span class="kt">bool</span> <span class="nf">unique_add</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

  <span class="cm">/**
    Initialize duplicate filter - allocate duplicate weedout tmp table

    @returns
      false initialization succeeded
      true  an error occur
  */</span>
  <span class="kt">bool</span> <span class="nf">init</span><span class="p">();</span>

  <span class="cm">/**
    Reset filter - drop all rowid records

    @param reinit  Whether to restart index scan
  */</span>
  <span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="kt">bool</span> <span class="n">reinit</span><span class="p">);</span>

  <span class="cm">/**
    Cleanup unique filter
  */</span>
  <span class="kt">void</span> <span class="nf">cleanup</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div> </div> </article><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"flayhhh/flayhhh.github.io","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,a])=>giscusScript.setAttribute(t,a)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Hao Luan. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>