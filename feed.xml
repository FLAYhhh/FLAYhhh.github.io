<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://flayhhh.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://flayhhh.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-07-12T15:47:47+00:00</updated><id>https://flayhhh.github.io/feed.xml</id><title type="html">blank</title><subtitle>A system programmer and resercher&apos;s blog. </subtitle><entry><title type="html">Ptbm design details (1): buffer pool中内存页标识符的重新设计 &amp;amp; 多文件地址映射管理</title><link href="https://flayhhh.github.io/blog/2023/PTBM-Design-Details-(1)-Buffer-Pool%E4%B8%AD%E5%86%85%E5%AD%98%E9%A1%B5%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1-&-%E5%A4%9A%E6%96%87%E4%BB%B6%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/" rel="alternate" type="text/html" title="Ptbm design details (1): buffer pool中内存页标识符的重新设计 &amp;amp; 多文件地址映射管理"/><published>2023-07-12T05:10:00+00:00</published><updated>2023-07-12T05:10:00+00:00</updated><id>https://flayhhh.github.io/blog/2023/PTBM%20Design%20Details%20(1):%20Buffer%20Pool%E4%B8%AD%E5%86%85%E5%AD%98%E9%A1%B5%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%20&amp;%20%E5%A4%9A%E6%96%87%E4%BB%B6%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86</id><content type="html" xml:base="https://flayhhh.github.io/blog/2023/PTBM-Design-Details-(1)-Buffer-Pool%E4%B8%AD%E5%86%85%E5%AD%98%E9%A1%B5%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1-&amp;-%E5%A4%9A%E6%96%87%E4%BB%B6%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/"><![CDATA[<h2 id="1-bufferdesc--ptedit_pte_t">1. BufferDesc &amp; ptedit_pte_t</h2> <p>BufferDesc是buffer manager中的重要类型. 对应buffer pool中的每个buffer frame, 都有与之对应的BufferDesc来描述该Buffer frame的状态. 换句话说, 每个内存页都需要一个BufferDesc描述其状态. 在Ptbm的设计中, pte可以替代bufferdesc的功能.</p> <p>首先给出这两个类型的定义：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ptedit_header.h</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">present</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// </span>
    <span class="kt">size_t</span> <span class="n">writeable</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">user_access</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">write_through</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">cache_disabled</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">accessed</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">dirty</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">global</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">ignored_2</span> <span class="o">:</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">pfn</span> <span class="o">:</span> <span class="mi">28</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">reserved_1</span> <span class="o">:</span> <span class="mi">12</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">ignored_1</span> <span class="o">:</span> <span class="mi">11</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">execution_disabled</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ptedit_pte_t</span><span class="p">;</span>
<span class="c1">// pte中预留了 12 + 11 + 3 = 26 bit</span>

<span class="c1">//==========================================================================</span>
<span class="c1">// buf_internals.h</span>
<span class="cm">/*
 * Buffer state is a single 32-bit variable where following data is combined.
 *
 * - 18 bits refcount
 * - 4 bits usage count
 * - 10 bits of flags
 *
 * Combining these values allows to perform some operations without locking
 * the buffer header, by modifying them together with a CAS loop.
 *
 * The definition of buffer state components is below.
 */</span>
<span class="cp">#define BUF_REFCOUNT_ONE 1
#define BUF_REFCOUNT_MASK ((1U &lt;&lt; 18) - 1)
#define BUF_USAGECOUNT_MASK 0x003C0000U
#define BUF_USAGECOUNT_ONE (1U &lt;&lt; 18)
#define BUF_USAGECOUNT_SHIFT 18
#define BUF_FLAG_MASK 0xFFC00000U
</span>
<span class="cm">/* Get refcount and usagecount from buffer state */</span>
<span class="cp">#define BUF_STATE_GET_REFCOUNT(state) ((state) &amp; BUF_REFCOUNT_MASK)
#define BUF_STATE_GET_USAGECOUNT(state) (((state) &amp; BUF_USAGECOUNT_MASK) &gt;&gt; BUF_USAGECOUNT_SHIFT)
</span><span class="cm">/*
 * Flags for buffer descriptors
 *
 * Note: BM_TAG_VALID essentially means that there is a buffer hashtable
 * entry associated with the buffer's tag.
 */</span>
<span class="cp">#define BM_LOCKED				(1U &lt;&lt; 22)	</span><span class="cm">/* buffer header is locked */</span><span class="cp">
#define BM_DIRTY				(1U &lt;&lt; 23)	</span><span class="cm">/* data needs writing */</span><span class="cp">
#define BM_VALID				(1U &lt;&lt; 24)	</span><span class="cm">/* data is valid */</span><span class="cp">
#define BM_TAG_VALID			(1U &lt;&lt; 25)	</span><span class="cm">/* tag is assigned */</span><span class="cp">
#define BM_IO_IN_PROGRESS		(1U &lt;&lt; 26)	</span><span class="cm">/* read or write in progress */</span><span class="cp">
#define BM_IO_ERROR				(1U &lt;&lt; 27)	</span><span class="cm">/* previous I/O failed */</span><span class="cp">
#define BM_JUST_DIRTIED			(1U &lt;&lt; 28)	</span><span class="cm">/* dirtied since write started */</span><span class="cp">
#define BM_PIN_COUNT_WAITER		(1U &lt;&lt; 29)	</span><span class="cm">/* have waiter for sole pin */</span><span class="cp">
#define BM_CHECKPOINT_NEEDED	(1U &lt;&lt; 30)	</span><span class="cm">/* must write for checkpoint */</span><span class="cp">
#define BM_PERMANENT			(1U &lt;&lt; 31)	</span><span class="cm">/* permanent buffer (not unlogged,
											 * or init fork) */</span><span class="cp">
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">BufferDesc</span>
<span class="p">{</span>
	<span class="n">BufferTag</span>	<span class="n">tag</span><span class="p">;</span>			<span class="cm">/* ID of page contained in buffer */</span>
	<span class="kt">int</span>			<span class="n">buf_id</span><span class="p">;</span>			<span class="cm">/* buffer's index number (from 0) */</span>

	<span class="cm">/* state of the tag, containing flags, refcount and usagecount */</span>
	<span class="n">pg_atomic_uint32</span> <span class="n">state</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">wait_backend_pgprocno</span><span class="p">;</span>	<span class="cm">/* backend of pin-count waiter */</span>
	<span class="kt">int</span>			<span class="n">freeNext</span><span class="p">;</span>		<span class="cm">/* link in freelist chain */</span>
	<span class="n">LWLock</span>		<span class="n">content_lock</span><span class="p">;</span>	<span class="cm">/* to lock access to buffer contents */</span>
<span class="p">}</span> <span class="n">BufferDesc</span><span class="p">;</span>
</code></pre></div></div> <p>BufferDesc.state中标记位（10个）和ptedit_pte_t中标记位的对比：</p> <table> <thead> <tr> <th style="text-align: left">BufferDesc.state</th> <th style="text-align: center">ptedit_pte_t</th> <th style="text-align: right">说明</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">BM_LOCKED</td> <td style="text-align: center"> </td> <td style="text-align: right">(存疑）猜测用于锁定整个BufferDesc。需要具体考察该bit的作用，例如：锁定BufferDesc的期间是否有除了修改成员之外的需求。如果只是为了原子的修改BufferDesc，则ptedit_pte_t不需要类似的标记，因为ptedit_pte_t为64bit大小，我们可以通过原子操作修改其中的bit。</td> </tr> <tr> <td style="text-align: left">BM_DIRTY</td> <td style="text-align: center">dirty</td> <td style="text-align: right">这两个标记可以合并</td> </tr> <tr> <td style="text-align: left">BM_VALID</td> <td style="text-align: center">present</td> <td style="text-align: right">（存疑）也许可以和present合并</td> </tr> <tr> <td style="text-align: left">BM_TAG_VALID</td> <td style="text-align: center"> </td> <td style="text-align: right">BufferDesc中需要存储tag，ptbm的设计不需要tag。</td> </tr> <tr> <td style="text-align: left">BM_IO_IN_PROGRESS</td> <td style="text-align: center">新增</td> <td style="text-align: right">ptbm需要新增类似的bit。1. 预读时分配物理内存， 并将pfn写入pte。但是present为false。2.进行异步IO或预读。在pte中设置IO_IN_PROGRESS标记位。 3.预读完成后再次将pte修改为有效状态 4.正式的读流程中需要check IO_IN_PROGESS标记位。</td> </tr> <tr> <td style="text-align: left">BM_IO_ERROR</td> <td style="text-align: center">新增</td> <td style="text-align: right">ptbm需要新增类似的bit。 如果IO错误，page中可能包含错误的内容。</td> </tr> <tr> <td style="text-align: left">BM_JUST_DIRTIED</td> <td style="text-align: center">新增</td> <td style="text-align: right">ptbm需要新增类似的bit（需要详细考察）</td> </tr> <tr> <td style="text-align: left">BM_PIN_COUNT_WAITER</td> <td style="text-align: center">新增</td> <td style="text-align: right">（存疑）BufferDesc中记录了等待者的id，但是pte中没有空间容纳等待者的id。解决方法：1. 不记录等待者。2. 使用哈希结构将等待者放在其他地方。</td> </tr> <tr> <td style="text-align: left">BM_CHECKPOINT_NEEDED</td> <td style="text-align: center">新增</td> <td style="text-align: right">（需要详细考察）需要详细地了解checkpoint逻辑。</td> </tr> <tr> <td style="text-align: left">BM_PERMANENT</td> <td style="text-align: center">新增</td> <td style="text-align: right">ptbm需要新增类似的bit。</td> </tr> <tr> <td style="text-align: left"> </td> <td style="text-align: center"> </td> <td style="text-align: right"> </td> </tr> </tbody> </table> <blockquote> <ul> <li>Buffer state is a single 32-bit variable where following data is combined. *</li> <li> <ul> <li>18 bits refcount</li> </ul> </li> <li> <ul> <li>4 bits usage count</li> </ul> </li> <li> <ul> <li>10 bits of flags</li> </ul> </li> </ul> </blockquote> <p>BufferDesc.state一共32bit，而pte中只预留了26bit， 所以需要压缩一下state。</p> <p>BufferDesc.State分为三个部分: refcount(18 bit), usage count(4 bit), flags(10 bit). 在上面的表格中，我们分析了如果使用ptbm的设计，flag可以缩减到 6bit。如果将refcount缩减到16bit，那么BufferDesc.state可以用26bit表示。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * The maximum allowed value of usage_count represents a tradeoff between
 * accuracy and speed of the clock-sweep buffer management algorithm.  A
 * large value (comparable to NBuffers) would approximate LRU semantics.
 * But it can take as many as BM_MAX_USAGE_COUNT+1 complete cycles of
 * clock sweeps to find a free buffer, so in practice we don't want the
 * value to be very large.
 */</span> 
<span class="cp">#define BM_MAX_USAGE_COUNT	5
</span></code></pre></div></div> <p>BufferDesc.state中的usage count似乎和替换算法有关。如果采用了ptbm，如何设计替换算法？</p> <p>原本的替换算法为clock sweeping，需要扫描buffer pool中所有的buffer。usage count在某个进程访问某个page时递增，在每次扫描到该buffer时递减。当usage count为0时，该buffer被替换。clock sweeping 遇到被pin住的buffer会跳过。</p> <p>重新设计ptbm需要扫描所有的物理page，并在page struct里记录usage count。</p> <p>这样 pte中也不需要存储usage count。</p> <p>经过以上的分析，pte中只需要记录refcount（18 bit）和flags （6 bit）。</p> <h2 id="2-进一步确认linux源码中pte的定义">2. 进一步确认linux源码中pte的定义</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// /arch/x86/include/asm/pgtable_types.h</span>

<span class="cp">#define _PAGE_BIT_PRESENT	0	</span><span class="cm">/* is present */</span><span class="cp">
#define _PAGE_BIT_RW		1	</span><span class="cm">/* writeable */</span><span class="cp">
#define _PAGE_BIT_USER		2	</span><span class="cm">/* userspace addressable */</span><span class="cp">
#define _PAGE_BIT_PWT		3	</span><span class="cm">/* page write through */</span><span class="cp">
#define _PAGE_BIT_PCD		4	</span><span class="cm">/* page cache disabled */</span><span class="cp">
#define _PAGE_BIT_ACCESSED	5	</span><span class="cm">/* was accessed (raised by CPU) */</span><span class="cp">
#define _PAGE_BIT_DIRTY		6	</span><span class="cm">/* was written to (raised by CPU) */</span><span class="cp">
#define _PAGE_BIT_PSE		7	</span><span class="cm">/* 4 MB (or 2MB) page */</span><span class="cp">
#define _PAGE_BIT_PAT		7	</span><span class="cm">/* on 4KB pages */</span><span class="cp">
#define _PAGE_BIT_GLOBAL	8	</span><span class="cm">/* Global TLB entry PPro+ */</span><span class="cp">
#define _PAGE_BIT_SOFTW1	9	</span><span class="cm">/* available for programmer */</span><span class="cp">
#define _PAGE_BIT_SOFTW2	10	</span><span class="cm">/* " */</span><span class="cp">
#define _PAGE_BIT_SOFTW3	11	</span><span class="cm">/* " */</span><span class="cp">
#define _PAGE_BIT_PAT_LARGE	12	</span><span class="cm">/* On 2MB or 1GB pages */</span><span class="cp">
#define _PAGE_BIT_SOFTW4	58	</span><span class="cm">/* available for programmer */</span><span class="cp">
#define _PAGE_BIT_PKEY_BIT0	59	</span><span class="cm">/* Protection Keys, bit 1/4 */</span><span class="cp">
#define _PAGE_BIT_PKEY_BIT1	60	</span><span class="cm">/* Protection Keys, bit 2/4 */</span><span class="cp">
#define _PAGE_BIT_PKEY_BIT2	61	</span><span class="cm">/* Protection Keys, bit 3/4 */</span><span class="cp">
#define _PAGE_BIT_PKEY_BIT3	62	</span><span class="cm">/* Protection Keys, bit 4/4 */</span><span class="cp">
#define _PAGE_BIT_NX		63	</span><span class="cm">/* No execute: only valid after cpuid check */</span><span class="cp">
</span>
<span class="cp">#define _PAGE_BIT_SPECIAL	_PAGE_BIT_SOFTW1
#define _PAGE_BIT_CPA_TEST	_PAGE_BIT_SOFTW1
#define _PAGE_BIT_UFFD_WP	_PAGE_BIT_SOFTW2 </span><span class="cm">/* userfaultfd wrprotected */</span><span class="cp">
#define _PAGE_BIT_SOFT_DIRTY	_PAGE_BIT_SOFTW3 </span><span class="cm">/* software dirty tracking */</span><span class="cp">
#define _PAGE_BIT_DEVMAP	_PAGE_BIT_SOFTW4
</span></code></pre></div></div> <p>关于pte中哪些bit可用，有很多不同的说法：</p> <ul> <li>https://stackoverflow.com/questions/50102068/how-to-use-page-bit-softw1 这篇文章说4个保留位不一定能全部使用，反而52-57可以使用。</li> <li>PTEditor的作者说只能使用4个保留位</li> <li>https://01.org/blogs/dave/2020/linux-consumption-x86-page-table-bits 这篇文章介绍了预留位的一些作用。</li> </ul> <p>一劳永逸的解决方法：</p> <p>除了BM_VALID/present， 其他flag都可以放在page header中。</p> <h2 id="3-build-and-manage-mmap">3. Build and manage Mmap</h2> <p>首先，我们类比一下传统buffer manager处理一次“读磁盘页”的流程：</p> <ol> <li>从storage manager中获取磁盘页地址;</li> <li>在buffer pool中获取一个buffer frame;</li> <li>在哈希表中建立page tag 到 buffer frame的映射;</li> </ol> <p>在这个过程中，所有文件的磁盘页都统一分散在哈希表中。一个文件和多个文件无需区别对待。</p> <p>而在ptbm中，由于mmap的映射是顺序的，尽管我们没有直接使用基于文件的mmap，但是在地址空间的对应关系上仍然和基于文件的mmap相同。我们将一段连续的虚拟内存空间映射到了一个文件中的一段连续的IO地址空间。由于我们计划使用共享内存，所以只有一段虚拟地质空间，但是每个releation都会对应一个或多个文件，所以出现了一个虚拟地址空间对应多个文件IO地址空间的情况。</p> <p><strong>如何处理这种一对多的关系？</strong></p> <p>我们打算采用分段的方式处理一对多的关系。每个文件IO空间都对应虚拟地址空间中的一段。一段的大小默认为2GB（可以调整默认值）。当文件大小超出当前虚拟地址空间中所分配的段大小时，重新在虚拟地址空间中分配2倍于原来段大小的空间。注意，这里只是重新分配虚拟地址空间，所以我们只需要操作页表，改变虚拟地址到物理地址的映射关系，而无需进行拷贝操作。</p> <p>为此我们定义一个bookkeeper类型，记录每个文件对应的起始映射地址和段大小。另外，我们希望每次读取磁盘页时能够直接获取该磁盘页所在文件的映射地址，而无需通过文件名查找哈希表找到映射地址，所以我们还需要将起始映射地址从bookkeeper同步到每个文件在pg中的元数据表示。</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">struct</span> <span class="nx">MappingSegmentShared</span> <span class="p">{</span>
  <span class="nx">char</span> <span class="nx">file_name</span><span class="p">[</span><span class="nx">N</span><span class="p">];</span> 
  <span class="k">void</span> <span class="o">*</span><span class="nx">mapping_start</span><span class="p">;</span>
  <span class="nx">size_t</span> <span class="nx">len</span><span class="p">;</span> <span class="c1">// count in byte, but align to 1GB.</span>
  <span class="nx">MappingSegmentShared</span> <span class="o">*</span><span class="nx">prev</span><span class="p">;</span>
  <span class="nx">MappingSegmentShared</span> <span class="o">*</span><span class="nx">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// bookkeeper 类型</span>
<span class="nx">struct</span> <span class="nx">PtbmShared</span> <span class="p">{</span>
  <span class="c1">// need util like vector</span>
  <span class="nx">LWLock</span> <span class="nx">lock</span><span class="p">;</span>
  <span class="nx">Hash_table</span> <span class="nx">segments</span><span class="p">;</span> <span class="c1">// sorted by mapping start.</span>
  <span class="nf">build_new_mapping</span><span class="p">();</span> <span class="c1">// when reading new file</span>
  <span class="nf">unmapping</span><span class="p">();</span>
  <span class="nf">extent_segment</span><span class="p">();</span> <span class="c1">// 扩容</span>
<span class="p">};</span>
</code></pre></div></div> <p>需要注意的是, ptbmShared以及成员segments都需要存放在共享内存中. 关于共享内存中的数据可结构, 可以参考“Postgresql Shared Hash Table”.</p> <p>下面给出ptbm book keeper草图:</p> <p><img src="/assets/img/ptbm_segments.jpeg" width="400" height="400"/></p> <p>下一步是根据草图在pg中实现ptbm的book keep. 另外需要将book keeper中的映射关系同步至file metadata cache中.</p>]]></content><author><name></name></author><category term="PG"/><category term="PT-BM"/><summary type="html"><![CDATA[1. BufferDesc &amp; ptedit_pte_t]]></summary></entry><entry><title type="html">Ptbm design details (2): 在file metadata cache缓存mmap映射地址</title><link href="https://flayhhh.github.io/blog/2023/PTBM-Design-Details-(2)-%E5%9C%A8File-metadata-cache%E7%BC%93%E5%AD%98Mmap%E6%98%A0%E5%B0%84%E5%9C%B0%E5%9D%80/" rel="alternate" type="text/html" title="Ptbm design details (2): 在file metadata cache缓存mmap映射地址"/><published>2023-07-12T05:10:00+00:00</published><updated>2023-07-12T05:10:00+00:00</updated><id>https://flayhhh.github.io/blog/2023/PTBM%20Design%20Details%20(2):%20%E5%9C%A8File%20metadata%20cache%E7%BC%93%E5%AD%98Mmap%E6%98%A0%E5%B0%84%E5%9C%B0%E5%9D%80</id><content type="html" xml:base="https://flayhhh.github.io/blog/2023/PTBM-Design-Details-(2)-%E5%9C%A8File-metadata-cache%E7%BC%93%E5%AD%98Mmap%E6%98%A0%E5%B0%84%E5%9C%B0%E5%9D%80/"><![CDATA[<h2 id="1-背景">1. 背景</h2> <p>在Design Details(1)中我们提到, 可以通过一个基于哈希表的book keeper管理所有文件到虚拟地址空间的映射: FileNaming → Mapping range. 但是我们不希望每次对某个文件的page进行read, write时都去查询这个book keeper, 所以我们还需要将映射关系缓存到每个文件的metadata cache中.</p> <h2 id="2-在pg中找到表示file-metadata-cache的数据结构">2. 在PG中找到表示File metadata cache的数据结构</h2> <p>目前File metadata cache只是我们对Storage manager管理文件方式的一个假设, 所以需要在代码中找到真正表示它的数据结构.</p> <h3 id="21-readbuffer">2.1 ReadBuffer</h3> <p>我的思路是从ReadBuffer开始找. 因为ReadBuffer的语义是给次一个磁盘页的位置, 将其内容读取到buffer frame中. PG在给定磁盘页位置(其中必然包含了文件id)进行IO时, 可能会使用我们上面假设的File metadata cache结构. 例如, 其中可能会包含文件描述符. 如果有这个变量, 我们期望它在每个backend中是全局唯一的, 这样我们一旦将映射关系缓存到File metadata cache中, 如果映射关系不发生变化, 则其生命周期就会和backend的生命周期一样长.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ReadBuffer -- a shorthand for ReadBufferExtended, for reading from main
 *		fork with RBM_NORMAL mode and default strategy.
 */</span>
<span class="n">Buffer</span>
<span class="nf">ReadBuffer</span><span class="p">(</span><span class="n">Relation</span> <span class="n">reln</span><span class="p">,</span> <span class="n">BlockNumber</span> <span class="n">blockNum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ReadBufferExtended</span><span class="p">(</span><span class="n">reln</span><span class="p">,</span> <span class="n">MAIN_FORKNUM</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span> <span class="n">RBM_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * ReadBufferExtended -- returns a buffer containing the requested
 *		block of the requested relation.  If the blknum
 *		requested is P_NEW, extend the relation file and
 *		allocate a new block.  (Caller is responsible for
 *		ensuring that only one backend tries to extend a
 *		relation at the same time!)
 *
 * Returns: the buffer number for the buffer containing
 *		the block read.  The returned buffer has been pinned.
 *		Does not return on error --- elog's instead.
 *
 * Assume when this function is called, that reln has been opened already.
 *
 * In RBM_NORMAL mode, the page is read from disk, and the page header is
 * validated.  An error is thrown if the page header is not valid.  (But
 * note that an all-zero page is considered "valid"; see
 * PageIsVerifiedExtended().)
 *
 * RBM_ZERO_ON_ERROR is like the normal mode, but if the page header is not
 * valid, the page is zeroed instead of throwing an error. This is intended
 * for non-critical data, where the caller is prepared to repair errors.
 *
 * In RBM_ZERO_AND_LOCK mode, if the page isn't in buffer cache already, it's
 * filled with zeros instead of reading it from disk.  Useful when the caller
 * is going to fill the page from scratch, since this saves I/O and avoids
 * unnecessary failure if the page-on-disk has corrupt page headers.
 * The page is returned locked to ensure that the caller has a chance to
 * initialize the page before it's made visible to others.
 * Caution: do not use this mode to read a page that is beyond the relation's
 * current physical EOF; that is likely to cause problems in md.c when
 * the page is modified and written out. P_NEW is OK, though.
 *
 * RBM_ZERO_AND_CLEANUP_LOCK is the same as RBM_ZERO_AND_LOCK, but acquires
 * a cleanup-strength lock on the page.
 *
 * RBM_NORMAL_NO_LOG mode is treated the same as RBM_NORMAL here.
 *
 * If strategy is not NULL, a nondefault buffer access strategy is used.
 * See buffer/README for details.
 */</span>
<span class="n">Buffer</span>
<span class="nf">ReadBufferExtended</span><span class="p">(</span><span class="n">Relation</span> <span class="n">reln</span><span class="p">,</span> <span class="n">ForkNumber</span> <span class="n">forkNum</span><span class="p">,</span> <span class="n">BlockNumber</span> <span class="n">blockNum</span><span class="p">,</span>
				   <span class="n">ReadBufferMode</span> <span class="n">mode</span><span class="p">,</span> <span class="n">BufferAccessStrategy</span> <span class="n">strategy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span>		<span class="n">hit</span><span class="p">;</span>
	<span class="n">Buffer</span>		<span class="n">buf</span><span class="p">;</span>

	<span class="cm">/*
	 * Reject attempts to read non-local temporary relations; we would be
	 * likely to get wrong data since we have no visibility into the owning
	 * session's local buffers.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RELATION_IS_OTHER_TEMP</span><span class="p">(</span><span class="n">reln</span><span class="p">))</span>
		<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
				<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_FEATURE_NOT_SUPPORTED</span><span class="p">),</span>
				 <span class="n">errmsg</span><span class="p">(</span><span class="s">"cannot access temporary tables of other sessions"</span><span class="p">)));</span>

	<span class="cm">/*
	 * Read the buffer, and update pgstat counters to reflect a cache hit or
	 * miss.
	 */</span>
	<span class="n">pgstat_count_buffer_read</span><span class="p">(</span><span class="n">reln</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">ReadBuffer_common</span><span class="p">(</span><span class="n">RelationGetSmgr</span><span class="p">(</span><span class="n">reln</span><span class="p">),</span> <span class="n">reln</span><span class="o">-&gt;</span><span class="n">rd_rel</span><span class="o">-&gt;</span><span class="n">relpersistence</span><span class="p">,</span>
							<span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hit</span><span class="p">)</span>
		<span class="n">pgstat_count_buffer_hit</span><span class="p">(</span><span class="n">reln</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * ReadBufferWithoutRelcache -- like ReadBufferExtended, but doesn't require
 *		a relcache entry for the relation.
 *
 * Pass permanent = true for a RELPERSISTENCE_PERMANENT relation, and
 * permanent = false for a RELPERSISTENCE_UNLOGGED relation. This function
 * cannot be used for temporary relations (and making that work might be
 * difficult, unless we only want to read temporary relations for our own
 * BackendId).
 */</span>
<span class="n">Buffer</span>
<span class="nf">ReadBufferWithoutRelcache</span><span class="p">(</span><span class="n">RelFileLocator</span> <span class="n">rlocator</span><span class="p">,</span> <span class="n">ForkNumber</span> <span class="n">forkNum</span><span class="p">,</span>
						  <span class="n">BlockNumber</span> <span class="n">blockNum</span><span class="p">,</span> <span class="n">ReadBufferMode</span> <span class="n">mode</span><span class="p">,</span>
						  <span class="n">BufferAccessStrategy</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">bool</span> <span class="n">permanent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span>		<span class="n">hit</span><span class="p">;</span>

	<span class="n">SMgrRelation</span> <span class="n">smgr</span> <span class="o">=</span> <span class="n">smgropen</span><span class="p">(</span><span class="n">rlocator</span><span class="p">,</span> <span class="n">InvalidBackendId</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ReadBuffer_common</span><span class="p">(</span><span class="n">smgr</span><span class="p">,</span> <span class="n">permanent</span> <span class="o">?</span> <span class="n">RELPERSISTENCE_PERMANENT</span> <span class="o">:</span>
							 <span class="n">RELPERSISTENCE_UNLOGGED</span><span class="p">,</span> <span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span>
							 <span class="n">mode</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hit</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>每个Relation有多个Fork, 每个Fork对应一个或多个文件. 可以参考: <a href="https://blog.devgenius.io/postgres-15-internals-2-files-and-forks-e2cc6da4695d">Postgres 15 internals #2: Files and forks</a></p> </blockquote> <p>我们感兴趣的是pg如何使用relation和fork找到对应的文件:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">buf</span> <span class="o">=</span> <span class="n">ReadBuffer_common</span><span class="p">(</span><span class="n">RelationGetSmgr</span><span class="p">(</span><span class="n">reln</span><span class="p">),</span> <span class="n">reln</span><span class="o">-&gt;</span><span class="n">rd_rel</span><span class="o">-&gt;</span><span class="n">relpersistence</span><span class="p">,</span>
							<span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hit</span><span class="p">);</span>
</code></pre></div></div> <p>可以看到到这里为止forkNum没有变化, 但是reln转换成了RelationGetSmgr(reln)传递给ReadBuffer_common.</p> <p>我们首先看一看RelationGetSmgr, 然后再看一看ReadBuffer_common.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * RelationGetSmgr
 *		Returns smgr file handle for a relation, opening it if needed.
 *
 * Very little code is authorized to touch rel-&gt;rd_smgr directly.  Instead
 * use this function to fetch its value.
 *
 * Note: since a relcache flush can cause the file handle to be closed again,
 * it's unwise to hold onto the pointer returned by this function for any
 * long period.  Recommended practice is to just re-execute RelationGetSmgr
 * each time you need to access the SMgrRelation.  It's quite cheap in
 * comparison to whatever an smgr function is going to do.
 */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">SMgrRelation</span>
<span class="nf">RelationGetSmgr</span><span class="p">(</span><span class="n">Relation</span> <span class="n">rel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rel</span><span class="o">-&gt;</span><span class="n">rd_smgr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">smgrsetowner</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rel</span><span class="o">-&gt;</span><span class="n">rd_smgr</span><span class="p">),</span> <span class="n">smgropen</span><span class="p">(</span><span class="n">rel</span><span class="o">-&gt;</span><span class="n">rd_locator</span><span class="p">,</span> <span class="n">rel</span><span class="o">-&gt;</span><span class="n">rd_backend</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">rel</span><span class="o">-&gt;</span><span class="n">rd_smgr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <blockquote> <p>relcache flush会导致file handle即rel→rd_smgr关闭, 如果仍然有人使用rel→rd_smgr怎么办?</p> </blockquote> <p>稍微看一看smgropen和smgrsetowner.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">为了阅读</span><span class="n">sgmropen</span><span class="p">,</span> <span class="err">熟悉需要熟悉几个类型</span><span class="p">.</span> 

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">RelationData</span> <span class="o">*</span><span class="n">Relation</span><span class="p">;</span>

<span class="cm">/*
 * Here are the contents of a relation cache entry.
 */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">RelationData</span>
<span class="p">{</span>
	<span class="n">RelFileLocator</span> <span class="n">rd_locator</span><span class="p">;</span>	<span class="cm">/* relation physical identifier */</span>
	<span class="n">SMgrRelation</span> <span class="n">rd_smgr</span><span class="p">;</span>		<span class="cm">/* cached file handle, or NULL */</span>
	<span class="kt">int</span>			<span class="n">rd_refcnt</span><span class="p">;</span>		<span class="cm">/* reference count */</span>
	<span class="n">BackendId</span>	<span class="n">rd_backend</span><span class="p">;</span>		<span class="cm">/* owning backend id, if temporary relation */</span>
	<span class="n">bool</span>		<span class="n">rd_islocaltemp</span><span class="p">;</span> <span class="cm">/* rel is a temp rel of this session */</span>
	<span class="n">bool</span>		<span class="n">rd_isnailed</span><span class="p">;</span>	<span class="cm">/* rel is nailed in cache */</span>
	<span class="n">bool</span>		<span class="n">rd_isvalid</span><span class="p">;</span>		<span class="cm">/* relcache entry is valid */</span>
	<span class="n">bool</span>		<span class="n">rd_indexvalid</span><span class="p">;</span>	<span class="cm">/* is rd_indexlist valid? (also rd_pkindex and
								 * rd_replidindex) */</span>
	<span class="n">bool</span>		<span class="n">rd_statvalid</span><span class="p">;</span>	<span class="cm">/* is rd_statlist valid? */</span>

  <span class="p">...</span>
<span class="p">}</span> <span class="n">RelationData</span><span class="p">;</span>

<span class="cm">/*
 * Augmenting a relfilelocator with the backend ID provides all the information
 * we need to locate the physical storage.  The backend ID is InvalidBackendId
 * for regular relations (those accessible to more than one backend), or the
 * owning backend's ID for backend-local relations.  Backend-local relations
 * are always transient and removed in case of a database crash; they are
 * never WAL-logged or fsync'd.
 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">RelFileLocatorBackend</span>
<span class="p">{</span>
	<span class="n">RelFileLocator</span> <span class="n">locator</span><span class="p">;</span>
	<span class="n">BackendId</span>	<span class="n">backend</span><span class="p">;</span>
<span class="p">}</span> <span class="n">RelFileLocatorBackend</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">SMgrRelationData</span> <span class="o">*</span><span class="n">SMgrRelation</span><span class="p">;</span>

<span class="cm">/*
 * smgr.c maintains a table of SMgrRelation objects, which are essentially
 * cached file handles.  An SMgrRelation is created (if not already present)
 * by smgropen(), and destroyed by smgrclose().  Note that neither of these
 * operations imply I/O, they just create or destroy a hashtable entry.
 * (But smgrclose() may release associated resources, such as OS-level file
 * descriptors.)
 *
 * An SMgrRelation may have an "owner", which is just a pointer to it from
 * somewhere else; smgr.c will clear this pointer if the SMgrRelation is
 * closed.  We use this to avoid dangling pointers from relcache to smgr
 * without having to make the smgr explicitly aware of relcache.  There
 * can't be more than one "owner" pointer per SMgrRelation, but that's
 * all we need.
 *
 * SMgrRelations that do not have an "owner" are considered to be transient,
 * and are deleted at end of transaction.
 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">SMgrRelationData</span>
<span class="p">{</span>
	<span class="cm">/* rlocator is the hashtable lookup key, so it must be first! */</span>
	<span class="n">RelFileLocatorBackend</span> <span class="n">smgr_rlocator</span><span class="p">;</span>	<span class="cm">/* relation physical identifier */</span>

	<span class="cm">/* pointer to owning pointer, or NULL if none */</span>
	<span class="k">struct</span> <span class="n">SMgrRelationData</span> <span class="o">**</span><span class="n">smgr_owner</span><span class="p">;</span>

	<span class="cm">/*
	 * The following fields are reset to InvalidBlockNumber upon a cache flush
	 * event, and hold the last known size for each fork.  This information is
	 * currently only reliable during recovery, since there is no cache
	 * invalidation for fork extension.
	 */</span>
	<span class="n">BlockNumber</span> <span class="n">smgr_targblock</span><span class="p">;</span> <span class="cm">/* current insertion target block */</span>
	<span class="n">BlockNumber</span> <span class="n">smgr_cached_nblocks</span><span class="p">[</span><span class="n">MAX_FORKNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>	<span class="cm">/* last known size */</span>

	<span class="cm">/* additional public fields may someday exist here */</span>

	<span class="cm">/*
	 * Fields below here are intended to be private to smgr.c and its
	 * submodules.  Do not touch them from elsewhere.
	 */</span>
	<span class="kt">int</span>			<span class="n">smgr_which</span><span class="p">;</span>		<span class="cm">/* storage manager selector */</span>

	<span class="cm">/*
	 * for md.c; per-fork arrays of the number of open segments
	 * (md_num_open_segs) and the segments themselves (md_seg_fds).
	 */</span>
	<span class="kt">int</span>			<span class="n">md_num_open_segs</span><span class="p">[</span><span class="n">MAX_FORKNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">_MdfdVec</span> <span class="o">*</span><span class="n">md_seg_fds</span><span class="p">[</span><span class="n">MAX_FORKNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* if unowned, list link in list of all unowned SMgrRelations */</span>
	<span class="n">dlist_node</span>	<span class="n">node</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SMgrRelationData</span><span class="p">;</span>

<span class="cm">/*
 * smgropen() -- Return an SMgrRelation object, creating it if need be.
 *
 * This does not attempt to actually open the underlying file.
 */</span>
<span class="n">SMgrRelation</span>
<span class="nf">smgropen</span><span class="p">(</span><span class="n">RelFileLocator</span> <span class="n">rlocator</span><span class="p">,</span> <span class="n">BackendId</span> <span class="n">backend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">RelFileLocatorBackend</span> <span class="n">brlocator</span><span class="p">;</span>
	<span class="n">SMgrRelation</span> <span class="n">reln</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">found</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">SMgrRelationHash</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* First time through: initialize the hash table */</span>
		<span class="n">HASHCTL</span>		<span class="n">ctl</span><span class="p">;</span>

		<span class="n">ctl</span><span class="p">.</span><span class="n">keysize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RelFileLocatorBackend</span><span class="p">);</span>
		<span class="n">ctl</span><span class="p">.</span><span class="n">entrysize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SMgrRelationData</span><span class="p">);</span>
		<span class="n">SMgrRelationHash</span> <span class="o">=</span> <span class="n">hash_create</span><span class="p">(</span><span class="s">"smgr relation table"</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span>
									   <span class="o">&amp;</span><span class="n">ctl</span><span class="p">,</span> <span class="n">HASH_ELEM</span> <span class="o">|</span> <span class="n">HASH_BLOBS</span><span class="p">);</span>
		<span class="n">dlist_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unowned_relns</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Look up or create an entry */</span>
	<span class="n">brlocator</span><span class="p">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">rlocator</span><span class="p">;</span>
	<span class="n">brlocator</span><span class="p">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span><span class="p">;</span>
	<span class="n">reln</span> <span class="o">=</span> <span class="p">(</span><span class="n">SMgrRelation</span><span class="p">)</span> <span class="n">hash_search</span><span class="p">(</span><span class="n">SMgrRelationHash</span><span class="p">,</span>
									  <span class="o">&amp;</span><span class="n">brlocator</span><span class="p">,</span>
									  <span class="n">HASH_ENTER</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found</span><span class="p">);</span>

	<span class="cm">/* Initialize it if not present before */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* hash_search already filled in the lookup key */</span>
		<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_targblock</span> <span class="o">=</span> <span class="n">InvalidBlockNumber</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">MAX_FORKNUM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_cached_nblocks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">InvalidBlockNumber</span><span class="p">;</span>
		<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_which</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* we only have md.c at present */</span>

		<span class="cm">/* implementation-specific initialization */</span>
		<span class="n">smgrsw</span><span class="p">[</span><span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_which</span><span class="p">].</span><span class="n">smgr_open</span><span class="p">(</span><span class="n">reln</span><span class="p">);</span>

		<span class="cm">/* it has no owner yet */</span>
		<span class="n">dlist_push_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unowned_relns</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reln</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">reln</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>关键数据结构: <strong>SMgrRelationHash</strong></p> <p>这个哈希表的映射关系为: RelFileLocatorBackend (关系)→ SMgrRelationData(文件句柄).</p> <p>另外通过unowned_relns将所有没有拥有者的SMgrRelationData链接起来.</p> <p>所有打开的relation都会被缓存到哈希表中, 在smgr_open中, 如果没有在哈希表中查询到relation, 则新创建一个entry, 并将其放入unowned_relns中. 另外还需要调用smgrsw[reln→smgr_which].smgr_open(). 选择具体设备的操作进行open.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">const</span> <span class="n">f_smgr</span> <span class="n">smgrsw</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* magnetic disk */</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">smgr_init</span> <span class="o">=</span> <span class="n">mdinit</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_shutdown</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_open</span> <span class="o">=</span> <span class="n">mdopen</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_close</span> <span class="o">=</span> <span class="n">mdclose</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_create</span> <span class="o">=</span> <span class="n">mdcreate</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_exists</span> <span class="o">=</span> <span class="n">mdexists</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_unlink</span> <span class="o">=</span> <span class="n">mdunlink</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_extend</span> <span class="o">=</span> <span class="n">mdextend</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_zeroextend</span> <span class="o">=</span> <span class="n">mdzeroextend</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_prefetch</span> <span class="o">=</span> <span class="n">mdprefetch</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_read</span> <span class="o">=</span> <span class="n">mdread</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_write</span> <span class="o">=</span> <span class="n">mdwrite</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_writeback</span> <span class="o">=</span> <span class="n">mdwriteback</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_nblocks</span> <span class="o">=</span> <span class="n">mdnblocks</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_truncate</span> <span class="o">=</span> <span class="n">mdtruncate</span><span class="p">,</span>
		<span class="p">.</span><span class="n">smgr_immedsync</span> <span class="o">=</span> <span class="n">mdimmedsync</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>通常reln→smgr_which的值为0. 默认为磁盘.</p> <p>继续阅读mdopen的代码:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * mdopen() -- Initialize newly-opened relation.
 */</span>
<span class="kt">void</span>
<span class="nf">mdopen</span><span class="p">(</span><span class="n">SMgrRelation</span> <span class="n">reln</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* mark it not open */</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">forknum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">forknum</span> <span class="o">&lt;=</span> <span class="n">MAX_FORKNUM</span><span class="p">;</span> <span class="n">forknum</span><span class="o">++</span><span class="p">)</span>
		<span class="n">reln</span><span class="o">-&gt;</span><span class="n">md_num_open_segs</span><span class="p">[</span><span class="n">forknum</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>现在看reln→md_num_open_segs[forknum]还是有点抽象, 所以还需要再探SMgrRelationData中的两个成员:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SMgrRelationData</span> <span class="p">{</span>
<span class="p">...</span>
  <span class="cm">/*
	 * for md.c; per-fork arrays of the number of open segments
	 * (md_num_open_segs) and the segments themselves (md_seg_fds).
	 */</span>
	<span class="kt">int</span>			<span class="n">md_num_open_segs</span><span class="p">[</span><span class="n">MAX_FORKNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 每个fork打开的segment(文件)数量</span>
	<span class="k">struct</span> <span class="n">_MdfdVec</span> <span class="o">*</span><span class="n">md_seg_fds</span><span class="p">[</span><span class="n">MAX_FORKNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 每个fork都对应一个_MdfdVec数组,</span>
                                           <span class="c1">// 数组中每个元素为segment</span>
																					 <span class="c1">//(包含segment编号和该segment的fd)</span>
<span class="p">...</span>
<span class="p">};</span>

<span class="err">以及</span> <span class="k">struct</span> <span class="n">_MdfdVec</span><span class="err">的定义</span><span class="o">:</span>

<span class="cm">/*
 * The magnetic disk storage manager keeps track of open file
 * descriptors in its own descriptor pool.  This is done to make it
 * easier to support relations that are larger than the operating
 * system's file size limit (often 2GBytes).  In order to do that,
 * we break relations up into "segment" files that are each shorter than
 * the OS file size limit.  The segment size is set by the RELSEG_SIZE
 * configuration constant in pg_config.h.
 *
 * On disk, a relation must consist of consecutively numbered segment
 * files in the pattern
 *	-- Zero or more full segments of exactly RELSEG_SIZE blocks each
 *	-- Exactly one partial segment of size 0 &lt;= size &lt; RELSEG_SIZE blocks
 *	-- Optionally, any number of inactive segments of size 0 blocks.
 * The full and partial segments are collectively the "active" segments.
 * Inactive segments are those that once contained data but are currently
 * not needed because of an mdtruncate() operation.  The reason for leaving
 * them present at size zero, rather than unlinking them, is that other
 * backends and/or the checkpointer might be holding open file references to
 * such segments.  If the relation expands again after mdtruncate(), such
 * that a deactivated segment becomes active again, it is important that
 * such file references still be valid --- else data might get written
 * out to an unlinked old copy of a segment file that will eventually
 * disappear.
 *
 * File descriptors are stored in the per-fork md_seg_fds arrays inside
 * SMgrRelation. The length of these arrays is stored in md_num_open_segs.
 * Note that a fork's md_num_open_segs having a specific value does not
 * necessarily mean the relation doesn't have additional segments; we may
 * just not have opened the next segment yet.  (We could not have "all
 * segments are in the array" as an invariant anyway, since another backend
 * could extend the relation while we aren't looking.)  We do not have
 * entries for inactive segments, however; as soon as we find a partial
 * segment, we assume that any subsequent segments are inactive.
 *
 * The entire MdfdVec array is palloc'd in the MdCxt memory context.
 */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_MdfdVec</span>
<span class="p">{</span>
	<span class="n">File</span>		<span class="n">mdfd_vfd</span><span class="p">;</span>		<span class="cm">/* fd number in fd.c's pool */</span>
	<span class="n">BlockNumber</span> <span class="n">mdfd_segno</span><span class="p">;</span>		<span class="cm">/* segment number, from 0 */</span>
<span class="p">}</span> <span class="n">MdfdVec</span><span class="p">;</span>
</code></pre></div></div> <p>现在清楚mdopen将relation的所有fork中打开的segment数量置为0.</p> <p>回到smgropen()这个函数, 它只是在哈希表中创建了一个SMgrRelationData entry, 并将其放入了一个无拥有者的链表中. 另外将该relation每个fork中的open segments数量置为0.</p> <p>接下来看ReadBuffer_common:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ReadBuffer_common -- common logic for all ReadBuffer variants
 *
 * *hit is set to true if the request was satisfied from shared buffer cache.
 */</span>
<span class="k">static</span> <span class="n">Buffer</span>
<span class="nf">ReadBuffer_common</span><span class="p">(</span><span class="n">SMgrRelation</span> <span class="n">smgr</span><span class="p">,</span> <span class="kt">char</span> <span class="n">relpersistence</span><span class="p">,</span> <span class="n">ForkNumber</span> <span class="n">forkNum</span><span class="p">,</span>
				  <span class="n">BlockNumber</span> <span class="n">blockNum</span><span class="p">,</span> <span class="n">ReadBufferMode</span> <span class="n">mode</span><span class="p">,</span>
				  <span class="n">BufferAccessStrategy</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">hit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="cm">/*
	 * Read in the page, unless the caller intends to overwrite it and just
	 * wants us to allocate a buffer.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_LOCK</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_CLEANUP_LOCK</span><span class="p">)</span>
		<span class="n">MemSet</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">bufBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BLCKSZ</span><span class="p">);</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="p">...</span>
		<span class="o">***</span><span class="n">smgrread</span><span class="p">(</span><span class="n">smgr</span><span class="p">,</span> <span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span> <span class="n">bufBlock</span><span class="p">);</span><span class="o">***</span>
		<span class="p">...</span>
	<span class="p">}</span>

  <span class="p">...</span>
	<span class="p">{</span>
		<span class="cm">/* Set BM_VALID, terminate IO, and wake up any waiters */</span>
		<span class="n">TerminateBufferIO</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">BM_VALID</span><span class="p">);</span>
	<span class="p">}</span>
  <span class="p">...</span>
	<span class="k">return</span> <span class="n">BufferDescriptorGetBuffer</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>具体代码参见附录A.1, 本文的重点是找到合适的file handle cache, 目前看来SMgrRelationData担任了这个角色, smgropen中只是初始化了smgr的成员, 现在期望通过详细观察sgmrread能够理清smgr的在io流程中的具体作用.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="n">smgr_read</span> <span class="o">=</span> <span class="n">mdread</span>

<span class="cm">/*
 * mdread() -- Read the specified block from a relation.
 */</span>
<span class="kt">void</span>
<span class="nf">mdread</span><span class="p">(</span><span class="n">SMgrRelation</span> <span class="n">reln</span><span class="p">,</span> <span class="n">ForkNumber</span> <span class="n">forknum</span><span class="p">,</span> <span class="n">BlockNumber</span> <span class="n">blocknum</span><span class="p">,</span>
	   <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">off_t</span>		<span class="n">seekpos</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nbytes</span><span class="p">;</span>
	<span class="n">MdfdVec</span>    <span class="o">*</span><span class="n">v</span><span class="p">;</span>

	<span class="cm">/* If this build supports direct I/O, the buffer must be I/O aligned. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PG_O_DIRECT</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">PG_IO_ALIGN_SIZE</span> <span class="o">&lt;=</span> <span class="n">BLCKSZ</span><span class="p">)</span>
		<span class="n">Assert</span><span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">buffer</span> <span class="o">==</span> <span class="n">TYPEALIGN</span><span class="p">(</span><span class="n">PG_IO_ALIGN_SIZE</span><span class="p">,</span> <span class="n">buffer</span><span class="p">));</span>

	<span class="n">TRACE_POSTGRESQL_SMGR_MD_READ_START</span><span class="p">(</span><span class="n">forknum</span><span class="p">,</span> <span class="n">blocknum</span><span class="p">,</span>
										<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">spcOid</span><span class="p">,</span>
										<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">dbOid</span><span class="p">,</span>
										<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">relNumber</span><span class="p">,</span>
										<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">backend</span><span class="p">);</span>

	<span class="n">v</span> <span class="o">=</span> <span class="n">_mdfd_getseg</span><span class="p">(</span><span class="n">reln</span><span class="p">,</span> <span class="n">forknum</span><span class="p">,</span> <span class="n">blocknum</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
					 <span class="n">EXTENSION_FAIL</span> <span class="o">|</span> <span class="n">EXTENSION_CREATE_RECOVERY</span><span class="p">);</span>

	<span class="n">seekpos</span> <span class="o">=</span> <span class="p">(</span><span class="kt">off_t</span><span class="p">)</span> <span class="n">BLCKSZ</span> <span class="o">*</span> <span class="p">(</span><span class="n">blocknum</span> <span class="o">%</span> <span class="p">((</span><span class="n">BlockNumber</span><span class="p">)</span> <span class="n">RELSEG_SIZE</span><span class="p">));</span>

	<span class="n">Assert</span><span class="p">(</span><span class="n">seekpos</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">off_t</span><span class="p">)</span> <span class="n">BLCKSZ</span> <span class="o">*</span> <span class="n">RELSEG_SIZE</span><span class="p">);</span>

	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">FileRead</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">mdfd_vfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">BLCKSZ</span><span class="p">,</span> <span class="n">seekpos</span><span class="p">,</span> <span class="n">WAIT_EVENT_DATA_FILE_READ</span><span class="p">);</span>

	<span class="n">TRACE_POSTGRESQL_SMGR_MD_READ_DONE</span><span class="p">(</span><span class="n">forknum</span><span class="p">,</span> <span class="n">blocknum</span><span class="p">,</span>
									   <span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">spcOid</span><span class="p">,</span>
									   <span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">dbOid</span><span class="p">,</span>
									   <span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">relNumber</span><span class="p">,</span>
									   <span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">backend</span><span class="p">,</span>
									   <span class="n">nbytes</span><span class="p">,</span>
									   <span class="n">BLCKSZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">!=</span> <span class="n">BLCKSZ</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
					<span class="p">(</span><span class="n">errcode_for_file_access</span><span class="p">(),</span>
					 <span class="n">errmsg</span><span class="p">(</span><span class="s">"could not read block %u in file </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">: %m"</span><span class="p">,</span>
							<span class="n">blocknum</span><span class="p">,</span> <span class="n">FilePathName</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">mdfd_vfd</span><span class="p">))));</span>

		<span class="cm">/*
		 * Short read: we are at or past EOF, or we read a partial block at
		 * EOF.  Normally this is an error; upper levels should never try to
		 * read a nonexistent block.  However, if zero_damaged_pages is ON or
		 * we are InRecovery, we should instead return zeroes without
		 * complaining.  This allows, for example, the case of trying to
		 * update a block that was later truncated away.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">zero_damaged_pages</span> <span class="o">||</span> <span class="n">InRecovery</span><span class="p">)</span>
			<span class="n">MemSet</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BLCKSZ</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
					<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_DATA_CORRUPTED</span><span class="p">),</span>
					 <span class="n">errmsg</span><span class="p">(</span><span class="s">"could not read block %u in file </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">: read only %d of %d bytes"</span><span class="p">,</span>
							<span class="n">blocknum</span><span class="p">,</span> <span class="n">FilePathName</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">mdfd_vfd</span><span class="p">),</span>
							<span class="n">nbytes</span><span class="p">,</span> <span class="n">BLCKSZ</span><span class="p">)));</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>md_read调用_mdfd_getseg初始化文件描述符.</p> <p>看到这里, 基本达到了寻找File metadata cache的目的. pg中File meta data cache就是SMgrRelationData.</p> <p>熟悉SMgrRelationData后, 需要纠正一些Book keeper中的设计.</p> <ul> <li>不能以文件为单位管理映射, 因为一个Fork可能有多个segment组成, 但是这些segment虽然是不同的文件, 但是IO空间相同. 所以book keeper中应该以relation + fork作为key, 映射到特定relation的特定fork对应的虚拟地址空间.</li> </ul> <h2 id="3-ptbm对smgrrelationdata的修改">3. PTBM对SMgrRelationData的修改</h2> <p>需要新增成员数组: <strong><em>md_fork_mapping_start</em></strong></p> <ul> <li>NULL值为无效值, 说明还没有建立映射.</li> <li>非NULL值为该fork在shared memory中的映射地址.</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SMgrRelationData</span> <span class="p">{</span>
<span class="p">...</span>
  <span class="cm">/*
	 * for md.c; per-fork arrays of the number of open segments
	 * (md_num_open_segs) and the segments themselves (md_seg_fds).
	 */</span>
	<span class="kt">int</span>			<span class="n">md_num_open_segs</span><span class="p">[</span><span class="n">MAX_FORKNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 每个fork打开的segment(文件)数量</span>
	<span class="k">struct</span> <span class="n">_MdfdVec</span> <span class="o">*</span><span class="n">md_seg_fds</span><span class="p">[</span><span class="n">MAX_FORKNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 每个fork都对应一个_MdfdVec数组,</span>
                                           <span class="c1">// 数组中每个元素为segment</span>
																					 <span class="c1">//(包含segment编号和该segment的fd)</span>
  <span class="o">***</span><span class="kt">void</span> <span class="o">*</span><span class="n">md_fork_mapping_start</span><span class="p">[</span><span class="n">MAX_FORKNUM</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span><span class="o">***</span>
<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="4-smgrrelationdata的所有权--并发安全">4. SMgrRelationData的所有权 &amp; 并发安全</h2> <blockquote> <p>首先抛出一个重要问题: PG如何保证SMgrRelationData时的并发安全?</p> </blockquote> <p>函数RelationGetSmgr()中调用了smgrsetowner设置smgr的所有权.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * smgrsetowner() -- Establish a long-lived reference to an SMgrRelation object
 *
 * There can be only one owner at a time; this is sufficient since currently
 * the only such owners exist in the relcache.
 */</span>
<span class="kt">void</span>
<span class="nf">smgrsetowner</span><span class="p">(</span><span class="n">SMgrRelation</span> <span class="o">*</span><span class="n">owner</span><span class="p">,</span> <span class="n">SMgrRelation</span> <span class="n">reln</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don't support "disowning" an SMgrRelation here, use smgrclearowner */</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">owner</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*
	 * First, unhook any old owner.  (Normally there shouldn't be any, but it
	 * seems possible that this can happen during swap_relation_files()
	 * depending on the order of processing.  It's ok to close the old
	 * relcache entry early in that case.)
	 *
	 * If there isn't an old owner, then the reln should be in the unowned
	 * list, and we need to remove it.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_owner</span><span class="p">)</span>
		<span class="o">*</span><span class="p">(</span><span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_owner</span><span class="p">)</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">dlist_delete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">reln</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="cm">/* Now establish the ownership relationship. */</span>
	<span class="n">reln</span><span class="o">-&gt;</span><span class="n">smgr_owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">reln</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>猜测(与smgrsetowner无关): smgr是process local的变量, 多进程读写同一个文件的并发安全由buffer manager通过buffer descriptor控制. 因为每个backend在读写磁盘页之前都会检查并设置buffer descriptor中的读写锁. 所以下层storage manager进行文件IO时可能是并发安全的.</p> <h2 id="a-附录">A. 附录</h2> <h3 id="a1-readbuffer_common解析">A.1 ReadBuffer_common解析</h3> <p>TODO</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ReadBuffer_common -- common logic for all ReadBuffer variants
 *
 * *hit is set to true if the request was satisfied from shared buffer cache.
 */</span>
<span class="k">static</span> <span class="n">Buffer</span>
<span class="nf">ReadBuffer_common</span><span class="p">(</span><span class="n">SMgrRelation</span> <span class="n">smgr</span><span class="p">,</span> <span class="kt">char</span> <span class="n">relpersistence</span><span class="p">,</span> <span class="n">ForkNumber</span> <span class="n">forkNum</span><span class="p">,</span>
				  <span class="n">BlockNumber</span> <span class="n">blockNum</span><span class="p">,</span> <span class="n">ReadBufferMode</span> <span class="n">mode</span><span class="p">,</span>
				  <span class="n">BufferAccessStrategy</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">hit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BufferDesc</span> <span class="o">*</span><span class="n">bufHdr</span><span class="p">;</span>
	<span class="n">Block</span>		<span class="n">bufBlock</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">found</span><span class="p">;</span>
	<span class="n">IOContext</span>	<span class="n">io_context</span><span class="p">;</span>
	<span class="n">IOObject</span>	<span class="n">io_object</span><span class="p">;</span>
	<span class="n">bool</span>		<span class="n">isLocalBuf</span> <span class="o">=</span> <span class="n">SmgrIsTemp</span><span class="p">(</span><span class="n">smgr</span><span class="p">);</span>

	<span class="o">*</span><span class="n">hit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*
	 * Backward compatibility path, most code should use ExtendBufferedRel()
	 * instead, as acquiring the extension lock inside ExtendBufferedRel()
	 * scales a lot better.
	 */</span>
  <span class="err">创建新的</span><span class="n">page</span><span class="p">,</span> <span class="err">兼容旧的写法</span><span class="p">.</span> <span class="err">新的写法在</span><span class="n">ExtendBufferedRel</span><span class="p">()</span><span class="err">中</span><span class="p">.</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">blockNum</span> <span class="o">==</span> <span class="n">P_NEW</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">uint32</span>		<span class="n">flags</span> <span class="o">=</span> <span class="n">EB_SKIP_EXTENSION_LOCK</span><span class="p">;</span>

		<span class="cm">/*
		 * Since no-one else can be looking at the page contents yet, there is
		 * no difference between an exclusive lock and a cleanup-strength
		 * lock.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_LOCK</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_CLEANUP_LOCK</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">EB_LOCK_FIRST</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">ExtendBufferedRel</span><span class="p">(</span><span class="n">EB_SMGR</span><span class="p">(</span><span class="n">smgr</span><span class="p">,</span> <span class="n">relpersistence</span><span class="p">),</span>
								 <span class="n">forkNum</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure we will have room to remember the buffer pin */</span>
	<span class="n">ResourceOwnerEnlargeBuffers</span><span class="p">(</span><span class="n">CurrentResourceOwner</span><span class="p">);</span>

	<span class="n">TRACE_POSTGRESQL_BUFFER_READ_START</span><span class="p">(</span><span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span>
									   <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">spcOid</span><span class="p">,</span>
									   <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">dbOid</span><span class="p">,</span>
									   <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">relNumber</span><span class="p">,</span>
									   <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">backend</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isLocalBuf</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * We do not use a BufferAccessStrategy for I/O of temporary tables.
		 * However, in some cases, the "strategy" may not be NULL, so we can't
		 * rely on IOContextForStrategy() to set the right IOContext for us.
		 * This may happen in cases like CREATE TEMPORARY TABLE AS...
		 */</span>
		<span class="n">io_context</span> <span class="o">=</span> <span class="n">IOCONTEXT_NORMAL</span><span class="p">;</span>
		<span class="n">io_object</span> <span class="o">=</span> <span class="n">IOOBJECT_TEMP_RELATION</span><span class="p">;</span>
		<span class="n">bufHdr</span> <span class="o">=</span> <span class="n">LocalBufferAlloc</span><span class="p">(</span><span class="n">smgr</span><span class="p">,</span> <span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
			<span class="n">pgBufferUsage</span><span class="p">.</span><span class="n">local_blks_hit</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_NORMAL</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_NORMAL_NO_LOG</span> <span class="o">||</span>
				 <span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_ON_ERROR</span><span class="p">)</span>
			<span class="n">pgBufferUsage</span><span class="p">.</span><span class="n">local_blks_read</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * lookup the buffer.  IO_IN_PROGRESS is set if the requested block is
		 * not currently in memory.
		 */</span>
		<span class="n">io_context</span> <span class="o">=</span> <span class="n">IOContextForStrategy</span><span class="p">(</span><span class="n">strategy</span><span class="p">);</span>
		<span class="n">io_object</span> <span class="o">=</span> <span class="n">IOOBJECT_RELATION</span><span class="p">;</span>
		<span class="n">bufHdr</span> <span class="o">=</span> <span class="n">BufferAlloc</span><span class="p">(</span><span class="n">smgr</span><span class="p">,</span> <span class="n">relpersistence</span><span class="p">,</span> <span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span>
							 <span class="n">strategy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found</span><span class="p">,</span> <span class="n">io_context</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
			<span class="n">pgBufferUsage</span><span class="p">.</span><span class="n">shared_blks_hit</span><span class="o">++</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_NORMAL</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_NORMAL_NO_LOG</span> <span class="o">||</span>
				 <span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_ON_ERROR</span><span class="p">)</span>
			<span class="n">pgBufferUsage</span><span class="p">.</span><span class="n">shared_blks_read</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* At this point we do NOT hold any locks. */</span>

	<span class="cm">/* if it was already in the buffer pool, we're done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Just need to update stats before we exit */</span>
		<span class="o">*</span><span class="n">hit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">VacuumPageHit</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pgstat_count_io_op</span><span class="p">(</span><span class="n">io_object</span><span class="p">,</span> <span class="n">io_context</span><span class="p">,</span> <span class="n">IOOP_HIT</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">VacuumCostActive</span><span class="p">)</span>
			<span class="n">VacuumCostBalance</span> <span class="o">+=</span> <span class="n">VacuumCostPageHit</span><span class="p">;</span>

		<span class="n">TRACE_POSTGRESQL_BUFFER_READ_DONE</span><span class="p">(</span><span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span>
										  <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">spcOid</span><span class="p">,</span>
										  <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">dbOid</span><span class="p">,</span>
										  <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">relNumber</span><span class="p">,</span>
										  <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">backend</span><span class="p">,</span>
										  <span class="n">found</span><span class="p">);</span>

		<span class="cm">/*
		 * In RBM_ZERO_AND_LOCK mode the caller expects the page to be locked
		 * on return.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isLocalBuf</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_LOCK</span><span class="p">)</span>
				<span class="n">LWLockAcquire</span><span class="p">(</span><span class="n">BufferDescriptorGetContentLock</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">),</span>
							  <span class="n">LW_EXCLUSIVE</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_CLEANUP_LOCK</span><span class="p">)</span>
				<span class="n">LockBufferForCleanup</span><span class="p">(</span><span class="n">BufferDescriptorGetBuffer</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">BufferDescriptorGetBuffer</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * if we have gotten to this point, we have allocated a buffer for the
	 * page but its contents are not yet valid.  IO_IN_PROGRESS is set for it,
	 * if it's a shared buffer.
	 */</span>
	<span class="n">Assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pg_atomic_read_u32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufHdr</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BM_VALID</span><span class="p">));</span>	<span class="cm">/* spinlock not needed */</span>

	<span class="n">bufBlock</span> <span class="o">=</span> <span class="n">isLocalBuf</span> <span class="o">?</span> <span class="n">LocalBufHdrGetBlock</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">)</span> <span class="o">:</span> <span class="n">BufHdrGetBlock</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">);</span>

	<span class="cm">/*
	 * Read in the page, unless the caller intends to overwrite it and just
	 * wants us to allocate a buffer.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_LOCK</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_CLEANUP_LOCK</span><span class="p">)</span>
		<span class="n">MemSet</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">bufBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BLCKSZ</span><span class="p">);</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">instr_time</span>	<span class="n">io_start</span> <span class="o">=</span> <span class="n">pgstat_prepare_io_time</span><span class="p">();</span>

		<span class="n">smgrread</span><span class="p">(</span><span class="n">smgr</span><span class="p">,</span> <span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span> <span class="n">bufBlock</span><span class="p">);</span>

		<span class="n">pgstat_count_io_op_time</span><span class="p">(</span><span class="n">io_object</span><span class="p">,</span> <span class="n">io_context</span><span class="p">,</span>
								<span class="n">IOOP_READ</span><span class="p">,</span> <span class="n">io_start</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* check for garbage data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageIsVerifiedExtended</span><span class="p">((</span><span class="n">Page</span><span class="p">)</span> <span class="n">bufBlock</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span>
									<span class="n">PIV_LOG_WARNING</span> <span class="o">|</span> <span class="n">PIV_REPORT_STAT</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_ON_ERROR</span> <span class="o">||</span> <span class="n">zero_damaged_pages</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">ereport</span><span class="p">(</span><span class="n">WARNING</span><span class="p">,</span>
						<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_DATA_CORRUPTED</span><span class="p">),</span>
						 <span class="n">errmsg</span><span class="p">(</span><span class="s">"invalid page in block %u of relation %s; zeroing out page"</span><span class="p">,</span>
								<span class="n">blockNum</span><span class="p">,</span>
								<span class="n">relpath</span><span class="p">(</span><span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">,</span> <span class="n">forkNum</span><span class="p">))));</span>
				<span class="n">MemSet</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">bufBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BLCKSZ</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
						<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_DATA_CORRUPTED</span><span class="p">),</span>
						 <span class="n">errmsg</span><span class="p">(</span><span class="s">"invalid page in block %u of relation %s"</span><span class="p">,</span>
								<span class="n">blockNum</span><span class="p">,</span>
								<span class="n">relpath</span><span class="p">(</span><span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">,</span> <span class="n">forkNum</span><span class="p">))));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * In RBM_ZERO_AND_LOCK / RBM_ZERO_AND_CLEANUP_LOCK mode, grab the buffer
	 * content lock before marking the page as valid, to make sure that no
	 * other backend sees the zeroed page before the caller has had a chance
	 * to initialize it.
	 *
	 * Since no-one else can be looking at the page contents yet, there is no
	 * difference between an exclusive lock and a cleanup-strength lock. (Note
	 * that we cannot use LockBuffer() or LockBufferForCleanup() here, because
	 * they assert that the buffer is already valid.)
	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_LOCK</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">RBM_ZERO_AND_CLEANUP_LOCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">isLocalBuf</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">LWLockAcquire</span><span class="p">(</span><span class="n">BufferDescriptorGetContentLock</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">),</span> <span class="n">LW_EXCLUSIVE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isLocalBuf</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Only need to adjust flags */</span>
		<span class="n">uint32</span>		<span class="n">buf_state</span> <span class="o">=</span> <span class="n">pg_atomic_read_u32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufHdr</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

		<span class="n">buf_state</span> <span class="o">|=</span> <span class="n">BM_VALID</span><span class="p">;</span>
		<span class="n">pg_atomic_unlocked_write_u32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufHdr</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">buf_state</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/* Set BM_VALID, terminate IO, and wake up any waiters */</span>
		<span class="n">TerminateBufferIO</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">BM_VALID</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">VacuumPageMiss</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">VacuumCostActive</span><span class="p">)</span>
		<span class="n">VacuumCostBalance</span> <span class="o">+=</span> <span class="n">VacuumCostPageMiss</span><span class="p">;</span>

	<span class="n">TRACE_POSTGRESQL_BUFFER_READ_DONE</span><span class="p">(</span><span class="n">forkNum</span><span class="p">,</span> <span class="n">blockNum</span><span class="p">,</span>
									  <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">spcOid</span><span class="p">,</span>
									  <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">dbOid</span><span class="p">,</span>
									  <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">locator</span><span class="p">.</span><span class="n">relNumber</span><span class="p">,</span>
									  <span class="n">smgr</span><span class="o">-&gt;</span><span class="n">smgr_rlocator</span><span class="p">.</span><span class="n">backend</span><span class="p">,</span>
									  <span class="n">found</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">BufferDescriptorGetBuffer</span><span class="p">(</span><span class="n">bufHdr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="PG"/><category term="PT-BM"/><summary type="html"><![CDATA[1. 背景]]></summary></entry><entry><title type="html">Postgresql Shared Hash Table</title><link href="https://flayhhh.github.io/blog/2023/PostgreSQL-Shared-Hash-Table/" rel="alternate" type="text/html" title="Postgresql Shared Hash Table"/><published>2023-07-12T02:30:00+00:00</published><updated>2023-07-12T02:30:00+00:00</updated><id>https://flayhhh.github.io/blog/2023/PostgreSQL-Shared-Hash-Table</id><content type="html" xml:base="https://flayhhh.github.io/blog/2023/PostgreSQL-Shared-Hash-Table/"><![CDATA[<p><img src="/assets/img/pg_hashtable.png" alt="pg_hashtable.png"/></p> <h2 id="1-背景">1. 背景</h2> <p>由于ptbm需要一个集中式的book keeper管理所有文件到虚拟地址的映射, 所以需要将book keeper放在共享内存中. 我们参考pg buffer manager中的hash table熟悉一下在pg中如何实现一个基于共享内存的数据结构.</p> <h2 id="2-初始化">2. 初始化</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ShmemInitHash -- Create and initialize, or attach to, a
 *		shared memory hash table.
 *
 * We assume caller is doing some kind of synchronization
 * so that two processes don't try to create/initialize the same
 * table at once.  (In practice, all creations are done in the postmaster
 * process; child processes should always be attaching to existing tables.)
 *
 * max_size is the estimated maximum number of hashtable entries.  This is
 * not a hard limit, but the access efficiency will degrade if it is
 * exceeded substantially (since it's used to compute directory size and
 * the hash table buckets will get overfull).
 *
 * init_size is the number of hashtable entries to preallocate.  For a table
 * whose maximum size is certain, this should be equal to max_size; that
 * ensures that no run-time out-of-shared-memory failures can occur.
 *
 * *infoP and hash_flags must specify at least the entry sizes and key
 * comparison semantics (see hash_create()).  Flag bits and values specific
 * to shared-memory hash tables are added here, except that callers may
 * choose to specify HASH_PARTITION and/or HASH_FIXED_SIZE.
 *
 * Note: before Postgres 9.0, this function returned NULL for some failure
 * cases.  Now, it always throws error instead, so callers need not check
 * for NULL.
 */</span>
<span class="n">HTAB</span> <span class="o">*</span>
<span class="nf">ShmemInitHash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>		<span class="cm">/* table string name for shmem index */</span>
			  <span class="kt">long</span> <span class="n">init_size</span><span class="p">,</span>	<span class="cm">/* initial table size */</span>
			  <span class="kt">long</span> <span class="n">max_size</span><span class="p">,</span>	<span class="cm">/* max size of the table */</span>
			  <span class="n">HASHCTL</span> <span class="o">*</span><span class="n">infoP</span><span class="p">,</span>	<span class="cm">/* info about key and bucket size */</span>
			  <span class="kt">int</span> <span class="n">hash_flags</span><span class="p">)</span>	<span class="cm">/* info about infoP */</span>
<span class="p">{</span>
	<span class="kt">bool</span>		<span class="n">found</span><span class="p">;</span>
	<span class="kt">void</span>	   <span class="o">*</span><span class="n">location</span><span class="p">;</span>

	<span class="cm">/*
	 * Hash tables allocated in shared memory have a fixed directory; it can't
	 * grow or other backends wouldn't be able to find it. So, make sure we
	 * make it big enough to start with.
	 *
	 * The shared memory allocator must be specified too.
	 */</span>
	<span class="n">infoP</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">infoP</span><span class="o">-&gt;</span><span class="n">max_dsize</span> <span class="o">=</span> <span class="n">hash_select_dirsize</span><span class="p">(</span><span class="n">max_size</span><span class="p">);</span>
	<span class="n">infoP</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">ShmemAllocNoError</span><span class="p">;</span>
	<span class="n">hash_flags</span> <span class="o">|=</span> <span class="n">HASH_SHARED_MEM</span> <span class="o">|</span> <span class="n">HASH_ALLOC</span> <span class="o">|</span> <span class="n">HASH_DIRSIZE</span><span class="p">;</span>

	<span class="cm">/* look it up in the shmem index */</span>
	<span class="n">location</span> <span class="o">=</span> <span class="n">ShmemInitStruct</span><span class="p">(</span><span class="n">name</span><span class="p">,</span>
							   <span class="n">hash_get_shared_size</span><span class="p">(</span><span class="n">infoP</span><span class="p">,</span> <span class="n">hash_flags</span><span class="p">),</span>
							   <span class="o">&amp;</span><span class="n">found</span><span class="p">);</span>

	<span class="cm">/*
	 * if it already exists, attach to it rather than allocate and initialize
	 * new space
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
		<span class="n">hash_flags</span> <span class="o">|=</span> <span class="n">HASH_ATTACH</span><span class="p">;</span>

	<span class="cm">/* Pass location of hashtable header to hash_create */</span>
	<span class="n">infoP</span><span class="o">-&gt;</span><span class="n">hctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHHDR</span> <span class="o">*</span><span class="p">)</span> <span class="n">location</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">hash_create</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">init_size</span><span class="p">,</span> <span class="n">infoP</span><span class="p">,</span> <span class="n">hash_flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>总结一下初始化阶段的重点:</p> <ul> <li>初始化共享内存data structure可以基于一个假设: postmaster负责初始化, backend只会attach.</li> <li>提供max_size作为预估的内存分配, 运行时超出max_size不会报错, 但是会出现性能下降.</li> <li>info中包含了该hashtable的元信息,例如预估大小、元素分配方法等等.</li> </ul> <h3 id="21-下面具体分析shmeminithash中使用的子函数">2.1 <strong>下面具体分析ShmemInitHash中使用的子函数:</strong></h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * ShmemAllocNoError -- allocate max-aligned chunk from shared memory
 *
 * As ShmemAlloc, but returns NULL if out of space, rather than erroring.
 */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">ShmemAllocNoError</span><span class="p">(</span><span class="n">Size</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Size</span>		<span class="n">allocated_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ShmemAllocRaw</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">allocated_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * ShmemAllocRaw -- allocate align chunk and return allocated size
 *
 * Also sets *allocated_size to the number of bytes allocated, which will
 * be equal to the number requested plus any padding we choose to add.
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">ShmemAllocRaw</span><span class="p">(</span><span class="n">Size</span> <span class="n">size</span><span class="p">,</span> <span class="n">Size</span> <span class="o">*</span><span class="n">allocated_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Size</span>		<span class="n">newStart</span><span class="p">;</span>
	<span class="n">Size</span>		<span class="n">newFree</span><span class="p">;</span>
	<span class="kt">void</span>	   <span class="o">*</span><span class="n">newSpace</span><span class="p">;</span>

	<span class="cm">/*
	 * Ensure all space is adequately aligned.  We used to only MAXALIGN this
	 * space but experience has proved that on modern systems that is not good
	 * enough.  Many parts of the system are very sensitive to critical data
	 * structures getting split across cache line boundaries.  To avoid that,
	 * attempt to align the beginning of the allocation to a cache line
	 * boundary.  The calling code will still need to be careful about how it
	 * uses the allocated space - e.g. by padding each element in an array of
	 * structures out to a power-of-two size - but without this, even that
	 * won't be sufficient.
	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">CACHELINEALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="o">*</span><span class="n">allocated_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">Assert</span><span class="p">(</span><span class="n">ShmemSegHdr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">SpinLockAcquire</span><span class="p">(</span><span class="n">ShmemLock</span><span class="p">);</span>

	<span class="n">newStart</span> <span class="o">=</span> <span class="n">ShmemSegHdr</span><span class="o">-&gt;</span><span class="n">freeoffset</span><span class="p">;</span>

	<span class="n">newFree</span> <span class="o">=</span> <span class="n">newStart</span> <span class="o">+</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newFree</span> <span class="o">&lt;=</span> <span class="n">ShmemSegHdr</span><span class="o">-&gt;</span><span class="n">totalsize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">newSpace</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">ShmemBase</span> <span class="o">+</span> <span class="n">newStart</span><span class="p">);</span>
		<span class="n">ShmemSegHdr</span><span class="o">-&gt;</span><span class="n">freeoffset</span> <span class="o">=</span> <span class="n">newFree</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">newSpace</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">SpinLockRelease</span><span class="p">(</span><span class="n">ShmemLock</span><span class="p">);</span>

	<span class="cm">/* note this assert is okay with newSpace == NULL */</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">newSpace</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">CACHELINEALIGN</span><span class="p">(</span><span class="n">newSpace</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">newSpace</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ===== ShmemSegHdr的定义</span>
<span class="k">static</span> <span class="n">PGShmemHeader</span> <span class="o">*</span><span class="n">ShmemSegHdr</span><span class="p">;</span>	<span class="cm">/* shared mem segment header */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">PGShmemHeader</span>	<span class="cm">/* standard header for all Postgres shmem */</span>
<span class="p">{</span>
	<span class="n">int32</span>		<span class="n">magic</span><span class="p">;</span>			<span class="cm">/* magic # to identify Postgres segments */</span>
<span class="cp">#define PGShmemMagic  679834894
</span>	<span class="n">pid_t</span>		<span class="n">creatorPID</span><span class="p">;</span>		<span class="cm">/* PID of creating process (set but unread) */</span>
	<span class="n">Size</span>		<span class="n">totalsize</span><span class="p">;</span>		<span class="cm">/* total size of segment */</span>
	<span class="n">Size</span>		<span class="n">freeoffset</span><span class="p">;</span>		<span class="cm">/* offset to first free space */</span>
	<span class="n">dsm_handle</span>	<span class="n">dsm_control</span><span class="p">;</span>	<span class="cm">/* ID of dynamic shared memory control seg */</span>
	<span class="kt">void</span>	   <span class="o">*</span><span class="n">index</span><span class="p">;</span>			<span class="cm">/* pointer to ShmemIndex table */</span>
<span class="cp">#ifndef WIN32					</span><span class="cm">/* Windows doesn't have useful inode#s */</span><span class="cp">
</span>	<span class="n">dev_t</span>		<span class="n">device</span><span class="p">;</span>			<span class="cm">/* device data directory is on */</span>
	<span class="n">ino_t</span>		<span class="n">inode</span><span class="p">;</span>			<span class="cm">/* inode number of data directory */</span>
<span class="cp">#endif
</span><span class="p">}</span> <span class="n">PGShmemHeader</span><span class="p">;</span>

<span class="c1">// =======Shmem的初始化</span>
<span class="cm">/*
 *	InitShmemAccess() --- set up basic pointers to shared memory.
 *
 * Note: the argument should be declared "PGShmemHeader *seghdr",
 * but we use void to avoid having to include ipc.h in shmem.h.
 */</span>
<span class="kt">void</span>
<span class="nf">InitShmemAccess</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">seghdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PGShmemHeader</span> <span class="o">*</span><span class="n">shmhdr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PGShmemHeader</span> <span class="o">*</span><span class="p">)</span> <span class="n">seghdr</span><span class="p">;</span>

	<span class="n">ShmemSegHdr</span> <span class="o">=</span> <span class="n">shmhdr</span><span class="p">;</span>
	<span class="n">ShmemBase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">shmhdr</span><span class="p">;</span>
	<span class="n">ShmemEnd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">ShmemBase</span> <span class="o">+</span> <span class="n">shmhdr</span><span class="o">-&gt;</span><span class="n">totalsize</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>按照cache line对齐的大小分配</li> <li>空间不足时会返回NULL</li> <li>从ShmemSegHdr中获取当前free address, 顺序向后分配.</li> <li>关于shared memory初始化, 参考:</li> </ul> <p><a href="https://www.notion.so/Postgresql-Shared-memory-797f17811e31459eb12680ea63dadd40?pvs=21">Postgresql Shared memory初始化</a></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Select an appropriate directory size for a hashtable with the given
 * maximum number of entries.
 * This is only needed for hashtables in shared memory, whose directories
 * cannot be expanded dynamically.
 * NB: assumes that all hash structure parameters have default values!
 *
 * XXX this had better agree with the behavior of init_htab()...
 */</span>
<span class="kt">long</span>
<span class="nf">hash_select_dirsize</span><span class="p">(</span><span class="kt">long</span> <span class="n">num_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span>		<span class="n">nBuckets</span><span class="p">,</span>
				<span class="n">nSegments</span><span class="p">,</span>
				<span class="n">nDirEntries</span><span class="p">;</span>

	<span class="cm">/* estimate number of buckets wanted */</span>
	<span class="n">nBuckets</span> <span class="o">=</span> <span class="n">next_pow2_long</span><span class="p">(</span><span class="n">num_entries</span><span class="p">);</span>
	<span class="cm">/* # of segments needed for nBuckets */</span>
	<span class="n">nSegments</span> <span class="o">=</span> <span class="n">next_pow2_long</span><span class="p">((</span><span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">DEF_SEGSIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* directory entries */</span>
	<span class="n">nDirEntries</span> <span class="o">=</span> <span class="n">DEF_DIRSIZE</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nDirEntries</span> <span class="o">&lt;</span> <span class="n">nSegments</span><span class="p">)</span>
		<span class="n">nDirEntries</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* dir_alloc doubles dsize at each call */</span>

	<span class="k">return</span> <span class="n">nDirEntries</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * Constants
 *
 * A hash table has a top-level "directory", each of whose entries points
 * to a "segment" of ssize bucket headers.  The maximum number of hash
 * buckets is thus dsize * ssize (but dsize may be expansible).  Of course,
 * the number of records in the table can be larger, but we don't want a
 * whole lot of records per bucket or performance goes down.
 *
 * In a hash table allocated in shared memory, the directory cannot be
 * expanded because it must stay at a fixed address.  The directory size
 * should be selected using hash_select_dirsize (and you'd better have
 * a good idea of the maximum number of entries!).  For non-shared hash
 * tables, the initial directory size can be left at the default.
 */</span>
<span class="cp">#define DEF_SEGSIZE			   256
#define DEF_SEGSIZE_SHIFT	   8	</span><span class="cm">/* must be log2(DEF_SEGSIZE) */</span><span class="cp">
#define DEF_DIRSIZE			   256
</span></code></pre></div></div> <ul> <li>entry是hash table的最小单元</li> <li>根据entry计算bucket数量</li> <li>根据bucket计算segment数量 (每个segment中默认有256个bucket)</li> <li>根据segment数量计算directory entries的数量 (疑惑)</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Compute the required initial memory allocation for a shared-memory
 * hashtable with the given parameters.  We need space for the HASHHDR
 * and for the (non expansible) directory.
 */</span>
<span class="n">Size</span>
<span class="nf">hash_get_shared_size</span><span class="p">(</span><span class="n">HASHCTL</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_DIRSIZE</span><span class="p">);</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">==</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_dsize</span><span class="p">);</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HASHHDR</span><span class="p">)</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HASHSEGMENT</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>根据info中的dsize和一个HASHSEGMENT的大小计算出整个hashtable需要的空间.</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * hash_create -- create a new dynamic hash table
 *
 *	tabname: a name for the table (for debugging purposes)
 *	nelem: maximum number of elements expected
 *	*info: additional table parameters, as indicated by flags
 *	flags: bitmask indicating which parameters to take from *info
 *
 * The flags value *must* include HASH_ELEM.  (Formerly, this was nominally
 * optional, but the default keysize and entrysize values were useless.)
 * The flags value must also include exactly one of HASH_STRINGS, HASH_BLOBS,
 * or HASH_FUNCTION, to define the key hashing semantics (C strings,
 * binary blobs, or custom, respectively).  Callers specifying a custom
 * hash function will likely also want to use HASH_COMPARE, and perhaps
 * also HASH_KEYCOPY, to control key comparison and copying.
 * Another often-used flag is HASH_CONTEXT, to allocate the hash table
 * under info-&gt;hcxt rather than under TopMemoryContext; the default
 * behavior is only suitable for session-lifespan hash tables.
 * Other flags bits are special-purpose and seldom used, except for those
 * associated with shared-memory hash tables, for which see ShmemInitHash().
 *
 * Fields in *info are read only when the associated flags bit is set.
 * It is not necessary to initialize other fields of *info.
 * Neither tabname nor *info need persist after the hash_create() call.
 *
 * Note: It is deprecated for callers of hash_create() to explicitly specify
 * string_hash, tag_hash, uint32_hash, or oid_hash.  Just set HASH_STRINGS or
 * HASH_BLOBS.  Use HASH_FUNCTION only when you want something other than
 * one of these.
 *
 * Note: for a shared-memory hashtable, nelem needs to be a pretty good
 * estimate, since we can't expand the table on the fly.  But an unshared
 * hashtable can be expanded on-the-fly, so it's better for nelem to be
 * on the small side and let the table grow if it's exceeded.  An overly
 * large nelem will penalize hash_seq_search speed without buying much.
 */</span>
<span class="n">HTAB</span> <span class="o">*</span>
<span class="nf">hash_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tabname</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nelem</span><span class="p">,</span> <span class="k">const</span> <span class="n">HASHCTL</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HTAB</span>	   <span class="o">*</span><span class="n">hashp</span><span class="p">;</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span><span class="p">;</span>

	<span class="cm">/*
	 * Hash tables now allocate space for key and data, but you have to say
	 * how much space to allocate.
	 */</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_ELEM</span><span class="p">);</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">entrysize</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">);</span>

	<span class="cm">/*
	 * For shared hash tables, we have a local hash header (HTAB struct) that
	 * we allocate in TopMemoryContext; all else is in shared memory.
	 *
	 * For non-shared hash tables, everything including the hash header is in
	 * a memory context created specially for the hash table --- this makes
	 * hash_destroy very simple.  The memory context is made a child of either
	 * a context specified by the caller, or TopMemoryContext if nothing is
	 * specified.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Set up to allocate the hash header */</span>
		<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">TopMemoryContext</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/* Create the hash table's private memory context */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_CONTEXT</span><span class="p">)</span>
			<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hcxt</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">TopMemoryContext</span><span class="p">;</span>
		<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">AllocSetContextCreate</span><span class="p">(</span><span class="n">CurrentDynaHashCxt</span><span class="p">,</span>
												   <span class="s">"dynahash"</span><span class="p">,</span>
												   <span class="n">ALLOCSET_DEFAULT_SIZES</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the hash header, plus a copy of the table name */</span>
	<span class="n">hashp</span> <span class="o">=</span> <span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="p">)</span> <span class="n">DynaHashAlloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HTAB</span><span class="p">)</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">tabname</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">MemSet</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HTAB</span><span class="p">));</span>

	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">hashp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span><span class="p">,</span> <span class="n">tabname</span><span class="p">);</span>

	<span class="cm">/* If we have a private context, label it with hashtable's name */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">))</span>
		<span class="n">MemoryContextSetIdentifier</span><span class="p">(</span><span class="n">CurrentDynaHashCxt</span><span class="p">,</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span><span class="p">);</span>

	<span class="cm">/*
	 * Select the appropriate hash function (see comments at head of file).
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_FUNCTION</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HASH_BLOBS</span> <span class="o">|</span> <span class="n">HASH_STRINGS</span><span class="p">)));</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_BLOBS</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_STRINGS</span><span class="p">));</span>
		<span class="cm">/* We can optimize hashing for common key sizes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uint32</span><span class="p">))</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">uint32_hash</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">tag_hash</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * string_hash used to be considered the default hash method, and in a
		 * non-assert build it effectively still is.  But we now consider it
		 * an assertion error to not say HASH_STRINGS explicitly.  To help
		 * catch mistaken usage of HASH_STRINGS, we also insist on a
		 * reasonably long string length: if the keysize is only 4 or 8 bytes,
		 * it's almost certainly an integer or pointer not a string.
		 */</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_STRINGS</span><span class="p">);</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">string_hash</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * If you don't specify a match function, it defaults to string_compare if
	 * you used string_hash, and to memcmp otherwise.
	 *
	 * Note: explicitly specifying string_hash is deprecated, because this
	 * might not work for callers in loadable modules on some platforms due to
	 * referencing a trampoline instead of the string_hash function proper.
	 * Specify HASH_STRINGS instead.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_COMPARE</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">==</span> <span class="n">string_hash</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="n">HashCompareFunc</span><span class="p">)</span> <span class="n">string_compare</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">;</span>

	<span class="cm">/*
	 * Similarly, the key-copying function defaults to strlcpy or memcpy.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_KEYCOPY</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keycopy</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">keycopy</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">==</span> <span class="n">string_hash</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * The signature of keycopy is meant for memcpy(), which returns
		 * void*, but strlcpy() returns size_t.  Since we never use the return
		 * value of keycopy, and size_t is pretty much always the same size as
		 * void *, this should be safe.  The extra cast in the middle is to
		 * avoid warnings from -Wcast-function-type.
		 */</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keycopy</span> <span class="o">=</span> <span class="p">(</span><span class="n">HashCopyFunc</span><span class="p">)</span> <span class="p">(</span><span class="n">pg_funcptr_t</span><span class="p">)</span> <span class="n">strlcpy</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keycopy</span> <span class="o">=</span> <span class="n">memcpy</span><span class="p">;</span>

	<span class="cm">/* And select the entry allocation function, too. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_ALLOC</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">DynaHashAlloc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * ctl structure and directory are preallocated for shared memory
		 * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as
		 * well.
		 */</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHSEGMENT</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HASHHDR</span><span class="p">));</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hcxt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isshared</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/* hash table already exists, we're just attaching to it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_ATTACH</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="cm">/* make local copies of some heavily-used values */</span>
			<span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">;</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">;</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">sshift</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">hashp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/* setup hash table defaults */</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hcxt</span> <span class="o">=</span> <span class="n">CurrentDynaHashCxt</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isshared</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHHDR</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HASHHDR</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">)</span>
			<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
					<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_OUT_OF_MEMORY</span><span class="p">),</span>
					 <span class="n">errmsg</span><span class="p">(</span><span class="s">"out of memory"</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">frozen</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">hdefault</span><span class="p">(</span><span class="n">hashp</span><span class="p">);</span>

	<span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_PARTITION</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/* Doesn't make sense to partition a local hash table */</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">);</span>

		<span class="cm">/*
		 * The number of partitions had better be a power of 2. Also, it must
		 * be less than INT_MAX (see init_htab()), so call the int version of
		 * next_pow2.
		 */</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_partitions</span> <span class="o">==</span> <span class="n">next_pow2_int</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">num_partitions</span><span class="p">));</span>

		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">num_partitions</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">num_partitions</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SEGMENT</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">;</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span> <span class="o">=</span> <span class="n">my_log2</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">);</span>
		<span class="cm">/* ssize had better be a power of 2 */</span>
		<span class="n">Assert</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * SHM hash tables have fixed directory size passed by the caller.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_DIRSIZE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">max_dsize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">max_dsize</span><span class="p">;</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remember the entry sizes, too */</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">;</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">entrysize</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">entrysize</span><span class="p">;</span>

	<span class="cm">/* make local copies of heavily-used constant fields */</span>
	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keysize</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">;</span>
	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">;</span>
	<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">sshift</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">;</span>

	<span class="cm">/* Build the hash directory structure */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init_htab</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span> <span class="n">nelem</span><span class="p">))</span>
		<span class="n">elog</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">"failed to initialize hash table </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span><span class="p">);</span>

	<span class="cm">/*
	 * For a shared hash table, preallocate the requested number of elements.
	 * This reduces problems with run-time out-of-shared-memory conditions.
	 *
	 * For a non-shared hash table, preallocate the requested number of
	 * elements if it's less than our chosen nelem_alloc.  This avoids wasting
	 * space if the caller correctly estimates a small table size.
	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_SHARED_MEM</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">nelem</span> <span class="o">&lt;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nelem_alloc</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span>			<span class="n">i</span><span class="p">,</span>
					<span class="n">freelist_partitions</span><span class="p">,</span>
					<span class="n">nelem_alloc</span><span class="p">,</span>
					<span class="n">nelem_alloc_first</span><span class="p">;</span>

		<span class="cm">/*
		 * If hash table is partitioned, give each freelist an equal share of
		 * the initial allocation.  Otherwise only freeList[0] is used.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">))</span>
			<span class="n">freelist_partitions</span> <span class="o">=</span> <span class="n">NUM_FREELISTS</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">freelist_partitions</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">nelem_alloc</span> <span class="o">=</span> <span class="n">nelem</span> <span class="o">/</span> <span class="n">freelist_partitions</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nelem_alloc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">nelem_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*
		 * Make sure we'll allocate all the requested elements; freeList[0]
		 * gets the excess if the request isn't divisible by NUM_FREELISTS.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nelem_alloc</span> <span class="o">*</span> <span class="n">freelist_partitions</span> <span class="o">&lt;</span> <span class="n">nelem</span><span class="p">)</span>
			<span class="n">nelem_alloc_first</span> <span class="o">=</span>
				<span class="n">nelem</span> <span class="o">-</span> <span class="n">nelem_alloc</span> <span class="o">*</span> <span class="p">(</span><span class="n">freelist_partitions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">nelem_alloc_first</span> <span class="o">=</span> <span class="n">nelem_alloc</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">freelist_partitions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">int</span>			<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nelem_alloc_first</span> <span class="o">:</span> <span class="n">nelem_alloc</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">element_alloc</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
				<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
						<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_OUT_OF_MEMORY</span><span class="p">),</span>
						 <span class="n">errmsg</span><span class="p">(</span><span class="s">"out of memory"</span><span class="p">)));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">HASH_FIXED_SIZE</span><span class="p">)</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isfixed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">hashp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>hash table有两个重要的头结构:</p> <ul> <li>HTAB (process local)</li> <li>HASHHDR (shmem)</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Top control structure for a hashtable --- in a shared table, each backend
 * has its own copy (OK since no fields change at runtime)
 */</span>
<span class="k">struct</span> <span class="n">HTAB</span>
<span class="p">{</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span><span class="p">;</span>			<span class="cm">/* =&gt; shared control information */</span>
	<span class="n">HASHSEGMENT</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>			<span class="cm">/* directory of segment starts */</span>
	<span class="n">HashValueFunc</span> <span class="n">hash</span><span class="p">;</span>			<span class="cm">/* hash function */</span>
	<span class="n">HashCompareFunc</span> <span class="n">match</span><span class="p">;</span>		<span class="cm">/* key comparison function */</span>
	<span class="n">HashCopyFunc</span> <span class="n">keycopy</span><span class="p">;</span>		<span class="cm">/* key copying function */</span>
	<span class="n">HashAllocFunc</span> <span class="n">alloc</span><span class="p">;</span>		<span class="cm">/* memory allocator */</span>
	<span class="n">MemoryContext</span> <span class="n">hcxt</span><span class="p">;</span>			<span class="cm">/* memory context if default allocator used */</span>
	<span class="kt">char</span>	   <span class="o">*</span><span class="n">tabname</span><span class="p">;</span>		<span class="cm">/* table name (for error messages) */</span>
	<span class="n">bool</span>		<span class="n">isshared</span><span class="p">;</span>		<span class="cm">/* true if table is in shared memory */</span>
	<span class="n">bool</span>		<span class="n">isfixed</span><span class="p">;</span>		<span class="cm">/* if true, don't enlarge */</span>

	<span class="cm">/* freezing a shared table isn't allowed, so we can keep state here */</span>
	<span class="n">bool</span>		<span class="n">frozen</span><span class="p">;</span>			<span class="cm">/* true = no more inserts allowed */</span>

	<span class="cm">/* We keep local copies of these fixed values to reduce contention */</span>
	<span class="n">Size</span>		<span class="n">keysize</span><span class="p">;</span>		<span class="cm">/* hash key length in bytes */</span>
	<span class="kt">long</span>		<span class="n">ssize</span><span class="p">;</span>			<span class="cm">/* segment size --- must be power of 2 */</span>
	<span class="kt">int</span>			<span class="n">sshift</span><span class="p">;</span>			<span class="cm">/* segment shift = log2(ssize) */</span>
<span class="p">};</span>

<span class="cm">/*
 * Header structure for a hash table --- contains all changeable info
 *
 * In a shared-memory hash table, the HASHHDR is in shared memory, while
 * each backend has a local HTAB struct.  For a non-shared table, there isn't
 * any functional difference between HASHHDR and HTAB, but we separate them
 * anyway to share code between shared and non-shared tables.
 */</span>
<span class="k">struct</span> <span class="n">HASHHDR</span>
<span class="p">{</span>
	<span class="cm">/*
	 * The freelist can become a point of contention in high-concurrency hash
	 * tables, so we use an array of freelists, each with its own mutex and
	 * nentries count, instead of just a single one.  Although the freelists
	 * normally operate independently, we will scavenge entries from freelists
	 * other than a hashcode's default freelist when necessary.
	 *
	 * If the hash table is not partitioned, only freeList[0] is used and its
	 * spinlock is not used at all; callers' locking is assumed sufficient.
	 */</span>
	<span class="n">FreeListData</span> <span class="n">freeList</span><span class="p">[</span><span class="n">NUM_FREELISTS</span><span class="p">];</span>

	<span class="cm">/* These fields can change, but not in a partitioned table */</span>
	<span class="cm">/* Also, dsize can't change in a shared table, even if unpartitioned */</span>
	<span class="kt">long</span>		<span class="n">dsize</span><span class="p">;</span>			<span class="cm">/* directory size */</span>
	<span class="kt">long</span>		<span class="n">nsegs</span><span class="p">;</span>			<span class="cm">/* number of allocated segments (&lt;= dsize) */</span>
	<span class="n">uint32</span>		<span class="n">max_bucket</span><span class="p">;</span>		<span class="cm">/* ID of maximum bucket in use */</span>
	<span class="n">uint32</span>		<span class="n">high_mask</span><span class="p">;</span>		<span class="cm">/* mask to modulo into entire table */</span>
	<span class="n">uint32</span>		<span class="n">low_mask</span><span class="p">;</span>		<span class="cm">/* mask to modulo into lower half of table */</span>

	<span class="cm">/* These fields are fixed at hashtable creation */</span>
	<span class="n">Size</span>		<span class="n">keysize</span><span class="p">;</span>		<span class="cm">/* hash key length in bytes */</span>
	<span class="n">Size</span>		<span class="n">entrysize</span><span class="p">;</span>		<span class="cm">/* total user element size in bytes */</span>
	<span class="kt">long</span>		<span class="n">num_partitions</span><span class="p">;</span> <span class="cm">/* # partitions (must be power of 2), or 0 */</span>
	<span class="kt">long</span>		<span class="n">max_dsize</span><span class="p">;</span>		<span class="cm">/* 'dsize' limit if directory is fixed size */</span>
	<span class="kt">long</span>		<span class="n">ssize</span><span class="p">;</span>			<span class="cm">/* segment size --- must be power of 2 */</span>
	<span class="kt">int</span>			<span class="n">sshift</span><span class="p">;</span>			<span class="cm">/* segment shift = log2(ssize) */</span>
	<span class="kt">int</span>			<span class="n">nelem_alloc</span><span class="p">;</span>	<span class="cm">/* number of entries to allocate at once */</span>

<span class="cp">#ifdef HASH_STATISTICS
</span>
	<span class="cm">/*
	 * Count statistics here.  NB: stats code doesn't bother with mutex, so
	 * counts could be corrupted a bit in a partitioned table.
	 */</span>
	<span class="kt">long</span>		<span class="n">accesses</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">collisions</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span>

<span class="cm">/*
 * HASHELEMENT is the private part of a hashtable entry.  The caller's data
 * follows the HASHELEMENT structure (on a MAXALIGN'd boundary).  The hash key
 * is expected to be at the start of the caller's hash entry data structure.
 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">HASHELEMENT</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">HASHELEMENT</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>	<span class="cm">/* link to next entry in same bucket */</span>
	<span class="n">uint32</span>		<span class="n">hashvalue</span><span class="p">;</span>		<span class="cm">/* hash function result for this entry */</span>
<span class="p">}</span> <span class="n">HASHELEMENT</span><span class="p">;</span>
</code></pre></div></div> <p>在hash_create中, 主要做了以下几件事(着重分析共享内存中hash table的初始化):</p> <ul> <li>分配hash header - HTAB</li> <li>初始化 HTAB成员 <ul> <li>哈希表名称</li> <li>哈希函数</li> <li>匹配函数</li> <li>key copy函数</li> <li>元素alloc函数</li> <li>hctl (指向HASSHDR, 即共享内存中的首地址)</li> <li>dir (指向HASSHDR后的空闲地址.)</li> </ul> </li> <li>初始化 HASSHDR成员 <ul> <li>partition数量</li> <li>初始化directory size (存疑)</li> <li>初始化key size, entry size</li> </ul> </li> <li>调用init_htab(hashp, nelem) // nelem: maximum number of elements expected</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Compute derived fields of hctl and build the initial directory/segment
 * arrays
 */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">init_htab</span><span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="n">hashp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nelem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
	<span class="n">HASHSEGMENT</span> <span class="o">*</span><span class="n">segp</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nbuckets</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nsegs</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="cm">/*
	 * initialize mutexes if it's a partitioned table
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_FREELISTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">SpinLockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mutex</span><span class="p">));</span>

	<span class="cm">/*
	 * Allocate space for the next greater power of two number of buckets,
	 * assuming a desired maximum load factor of 1.
	 */</span>
	<span class="n">nbuckets</span> <span class="o">=</span> <span class="n">next_pow2_int</span><span class="p">(</span><span class="n">nelem</span><span class="p">);</span>

	<span class="cm">/*
	 * In a partitioned table, nbuckets must be at least equal to
	 * num_partitions; were it less, keys with apparently different partition
	 * numbers would map to the same bucket, breaking partition independence.
	 * (Normally nbuckets will be much bigger; this is just a safety check.)
	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">nbuckets</span> <span class="o">&lt;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">num_partitions</span><span class="p">)</span>
		<span class="n">nbuckets</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">max_bucket</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">low_mask</span> <span class="o">=</span> <span class="n">nbuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">high_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbuckets</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*
	 * Figure number of directory segments needed, round up to a power of 2
	 */</span>
	<span class="n">nsegs</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">nsegs</span> <span class="o">=</span> <span class="n">next_pow2_int</span><span class="p">(</span><span class="n">nsegs</span><span class="p">);</span>

	<span class="cm">/*
	 * Make sure directory is big enough. If pre-allocated directory is too
	 * small, choke (caller screwed up).
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nsegs</span> <span class="o">&gt;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">))</span>
			<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">nsegs</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate a directory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hcxt</span><span class="p">;</span>
		<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHSEGMENT</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HASHSEGMENT</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate initial segments */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">segp</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nsegs</span> <span class="o">&lt;</span> <span class="n">nsegs</span><span class="p">;</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nsegs</span><span class="o">++</span><span class="p">,</span> <span class="n">segp</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="o">*</span><span class="n">segp</span> <span class="o">=</span> <span class="n">seg_alloc</span><span class="p">(</span><span class="n">hashp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">segp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Choose number of entries to allocate at a time */</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nelem_alloc</span> <span class="o">=</span> <span class="n">choose_nelem_alloc</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">entrysize</span><span class="p">);</span>

<span class="cp">#ifdef HASH_DEBUG
</span>	<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"init_htab:</span><span class="se">\n</span><span class="s">%s%p</span><span class="se">\n</span><span class="s">%s%ld</span><span class="se">\n</span><span class="s">%s%ld</span><span class="se">\n</span><span class="s">%s%d</span><span class="se">\n</span><span class="s">%s%ld</span><span class="se">\n</span><span class="s">%s%u</span><span class="se">\n</span><span class="s">%s%x</span><span class="se">\n</span><span class="s">%s%x</span><span class="se">\n</span><span class="s">%s%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
			<span class="s">"TABLE POINTER   "</span><span class="p">,</span> <span class="n">hashp</span><span class="p">,</span>
			<span class="s">"DIRECTORY SIZE  "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">,</span>
			<span class="s">"SEGMENT SIZE    "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">,</span>
			<span class="s">"SEGMENT SHIFT   "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">,</span>
			<span class="s">"MAX BUCKET      "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">max_bucket</span><span class="p">,</span>
			<span class="s">"HIGH MASK       "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">high_mask</span><span class="p">,</span>
			<span class="s">"LOW  MASK       "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">low_mask</span><span class="p">,</span>
			<span class="s">"NSEGS           "</span><span class="p">,</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">nsegs</span><span class="p">);</span>
<span class="cp">#endif
</span>	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>初始化freeList[i].mutex</li> <li>初始化nbuckets (每个bucket一个entry)</li> <li>初始化max_bucket, low_mask, high_mask(存疑)</li> <li>计算nsegs(segment数量)</li> <li>分配segment</li> <li>初始化nelem_alloc(一次性分配的元素个数)</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * allocate some new elements and link them into the indicated free list
 */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">element_alloc</span><span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="n">hashp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nelem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">freelist_idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
	<span class="n">Size</span>		<span class="n">elementSize</span><span class="p">;</span>
	<span class="n">HASHELEMENT</span> <span class="o">*</span><span class="n">firstElement</span><span class="p">;</span>
	<span class="n">HASHELEMENT</span> <span class="o">*</span><span class="n">tmpElement</span><span class="p">;</span>
	<span class="n">HASHELEMENT</span> <span class="o">*</span><span class="n">prevElement</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isfixed</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Each element has a HASHELEMENT header plus user data. */</span>
	<span class="n">elementSize</span> <span class="o">=</span> <span class="n">MAXALIGN</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">HASHELEMENT</span><span class="p">))</span> <span class="o">+</span> <span class="n">MAXALIGN</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">entrysize</span><span class="p">);</span>

	<span class="n">CurrentDynaHashCxt</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hcxt</span><span class="p">;</span>
	<span class="n">firstElement</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHELEMENT</span> <span class="o">*</span><span class="p">)</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">nelem</span> <span class="o">*</span> <span class="n">elementSize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">firstElement</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* prepare to link all the new entries into the freelist */</span>
	<span class="n">prevElement</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tmpElement</span> <span class="o">=</span> <span class="n">firstElement</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nelem</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">tmpElement</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">prevElement</span><span class="p">;</span>
		<span class="n">prevElement</span> <span class="o">=</span> <span class="n">tmpElement</span><span class="p">;</span>
		<span class="n">tmpElement</span> <span class="o">=</span> <span class="p">(</span><span class="n">HASHELEMENT</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">tmpElement</span><span class="p">)</span> <span class="o">+</span> <span class="n">elementSize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* if partitioned, must lock to touch freeList */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
		<span class="n">SpinLockAcquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

	<span class="cm">/* freelist could be nonempty if two backends did this concurrently */</span>
	<span class="n">firstElement</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">freeList</span><span class="p">;</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">freeList</span> <span class="o">=</span> <span class="n">prevElement</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
		<span class="n">SpinLockRelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="22-初始化shmem-data-structure的时机">2.2 初始化shmem data structure的时机</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CreateSharedMemoryAndSemaphores</span>
 <span class="o">-</span> <span class="n">InitBufferPool</span>
	<span class="o">-</span> <span class="n">StrategyInitialize</span>
		<span class="o">-</span> <span class="n">InitBufTable</span>
			<span class="o">-</span> <span class="n">ShmemInitHash</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Static</span> <span class="n">HTAB</span> <span class="o">*</span><span class="n">SharedBufHash</span>
</code></pre></div></div> <h2 id="3-使用shmem-data-structure">3. 使用shmem data structure</h2> <p>摘取一段hash_create中的注释:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 <span class="cm">/* For shared hash tables, we have a local hash header (HTAB struct) that
	 we allocate in TopMemoryContext; all else is in shared memory. */</span>
</code></pre></div></div> <p>HTAB(hash 表头)是process local的变量. 所以使用shared hash table的第一步是: 每个backend进程创建HTAB, 并且将HTAB指向共享内存.</p> <p>pg在fork backend进程时, 会在每个backend进程初始化时调用InitBufTable. 而InitBufTable中又调用了ShmemInitHash(). 也就是说每个shared data structure除了需要在postmaster中使用ShmemInitxxx()初始化之外, 还需在backend进程中重新调用ShmemInitxxx()找到共享内存的位置.第一次调用时, pg会在shmem index中创建该数据结构. 第二次调用时, 查找shmem index获取其在shmem中的具体位置.</p> <p>后续得到shared data structure的地址后, 使用对应的访问函数操作即可.</p> <h3 id="31-hash-search">3.1 hash search</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * hash_search -- look up key in table and perform action
 * hash_search_with_hash_value -- same, with key's hash value already computed
 *
 * action is one of:
 *		HASH_FIND: look up key in table
 *		HASH_ENTER: look up key in table, creating entry if not present
 *		HASH_ENTER_NULL: same, but return NULL if out of memory
 *		HASH_REMOVE: look up key in table, remove entry if present
 *
 * Return value is a pointer to the element found/entered/removed if any,
 * or NULL if no match was found.  (NB: in the case of the REMOVE action,
 * the result is a dangling pointer that shouldn't be dereferenced!)
 *
 * HASH_ENTER will normally ereport a generic "out of memory" error if
 * it is unable to create a new entry.  The HASH_ENTER_NULL operation is
 * the same except it will return NULL if out of memory.
 *
 * If foundPtr isn't NULL, then *foundPtr is set true if we found an
 * existing entry in the table, false otherwise.  This is needed in the
 * HASH_ENTER case, but is redundant with the return value otherwise.
 *
 * For hash_search_with_hash_value, the hashvalue parameter must have been
 * calculated with get_hash_value().
 */</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">hash_search</span><span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="n">hashp</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">keyPtr</span><span class="p">,</span>
			<span class="n">HASHACTION</span> <span class="n">action</span><span class="p">,</span>
			<span class="n">bool</span> <span class="o">*</span><span class="n">foundPtr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hash_search_with_hash_value</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span>
									   <span class="n">keyPtr</span><span class="p">,</span>
									   <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">(</span><span class="n">keyPtr</span><span class="p">,</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">),</span>
									   <span class="n">action</span><span class="p">,</span>
									   <span class="n">foundPtr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">hash_search_with_hash_value</span><span class="p">(</span><span class="n">HTAB</span> <span class="o">*</span><span class="n">hashp</span><span class="p">,</span>
							<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">keyPtr</span><span class="p">,</span>
							<span class="n">uint32</span> <span class="n">hashvalue</span><span class="p">,</span>
							<span class="n">HASHACTION</span> <span class="n">action</span><span class="p">,</span>
							<span class="n">bool</span> <span class="o">*</span><span class="n">foundPtr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">HASHHDR</span>    <span class="o">*</span><span class="n">hctl</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">hctl</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">freelist_idx</span> <span class="o">=</span> <span class="n">FREELIST_IDX</span><span class="p">(</span><span class="n">hctl</span><span class="p">,</span> <span class="n">hashvalue</span><span class="p">);</span>
	<span class="n">Size</span>		<span class="n">keysize</span><span class="p">;</span>
	<span class="n">uint32</span>		<span class="n">bucket</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">segment_num</span><span class="p">;</span>
	<span class="kt">long</span>		<span class="n">segment_ndx</span><span class="p">;</span>
	<span class="n">HASHSEGMENT</span> <span class="n">segp</span><span class="p">;</span>
	<span class="n">HASHBUCKET</span>	<span class="n">currBucket</span><span class="p">;</span>
	<span class="n">HASHBUCKET</span> <span class="o">*</span><span class="n">prevBucketPtr</span><span class="p">;</span>
	<span class="n">HashCompareFunc</span> <span class="n">match</span><span class="p">;</span>

<span class="cp">#ifdef HASH_STATISTICS
</span>	<span class="n">hash_accesses</span><span class="o">++</span><span class="p">;</span>
	<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">accesses</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif
</span>
	<span class="cm">/*
	 * If inserting, check if it is time to split a bucket.
	 *
	 * NOTE: failure to expand table is not a fatal error, it just means we
	 * have to run at higher fill factor than we wanted.  However, if we're
	 * using the palloc allocator then it will throw error anyway on
	 * out-of-memory, so we must do this before modifying the table.
	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">HASH_ENTER</span> <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">HASH_ENTER_NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*
		 * Can't split if running in partitioned mode, nor if frozen, nor if
		 * table is the subject of any active hash_seq_search scans.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">nentries</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">max_bucket</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">frozen</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">has_seq_scans</span><span class="p">(</span><span class="n">hashp</span><span class="p">))</span>
			<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">expand_table</span><span class="p">(</span><span class="n">hashp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*
	 * Do the initial lookup
	 */</span>
	<span class="n">bucket</span> <span class="o">=</span> <span class="n">calc_bucket</span><span class="p">(</span><span class="n">hctl</span><span class="p">,</span> <span class="n">hashvalue</span><span class="p">);</span>

	<span class="n">segment_num</span> <span class="o">=</span> <span class="n">bucket</span> <span class="o">&gt;&gt;</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">sshift</span><span class="p">;</span>
	<span class="n">segment_ndx</span> <span class="o">=</span> <span class="n">MOD</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">ssize</span><span class="p">);</span>

	<span class="n">segp</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">dir</span><span class="p">[</span><span class="n">segment_num</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">segp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">hash_corrupted</span><span class="p">(</span><span class="n">hashp</span><span class="p">);</span>

	<span class="n">prevBucketPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">segp</span><span class="p">[</span><span class="n">segment_ndx</span><span class="p">];</span>
	<span class="n">currBucket</span> <span class="o">=</span> <span class="o">*</span><span class="n">prevBucketPtr</span><span class="p">;</span>

	<span class="cm">/*
	 * Follow collision chain looking for matching key
	 */</span>
	<span class="n">match</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">match</span><span class="p">;</span>		<span class="cm">/* save one fetch in inner loop */</span>
	<span class="n">keysize</span> <span class="o">=</span> <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keysize</span><span class="p">;</span>	<span class="cm">/* ditto */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">hashvalue</span> <span class="o">==</span> <span class="n">hashvalue</span> <span class="o">&amp;&amp;</span>
			<span class="n">match</span><span class="p">(</span><span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">),</span> <span class="n">keyPtr</span><span class="p">,</span> <span class="n">keysize</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prevBucketPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
		<span class="n">currBucket</span> <span class="o">=</span> <span class="o">*</span><span class="n">prevBucketPtr</span><span class="p">;</span>
<span class="cp">#ifdef HASH_STATISTICS
</span>		<span class="n">hash_collisions</span><span class="o">++</span><span class="p">;</span>
		<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">collisions</span><span class="o">++</span><span class="p">;</span>
<span class="cp">#endif
</span>	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">foundPtr</span><span class="p">)</span>
		<span class="o">*</span><span class="n">foundPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">bool</span><span class="p">)</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*
	 * OK, now what?
	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">case</span> <span class="n">HASH_FIND</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">HASH_REMOVE</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/* if partitioned, must lock to touch nentries and freeList */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
					<span class="n">SpinLockAcquire</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">mutex</span><span class="p">));</span>

				<span class="cm">/* delete the record from the appropriate nentries counter. */</span>
				<span class="n">Assert</span><span class="p">(</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">nentries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">nentries</span><span class="o">--</span><span class="p">;</span>

				<span class="cm">/* remove record from hash bucket's chain. */</span>
				<span class="o">*</span><span class="n">prevBucketPtr</span> <span class="o">=</span> <span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

				<span class="cm">/* add the record to the appropriate freelist. */</span>
				<span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">freeList</span><span class="p">;</span>
				<span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">freeList</span> <span class="o">=</span> <span class="n">currBucket</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">IS_PARTITIONED</span><span class="p">(</span><span class="n">hctl</span><span class="p">))</span>
					<span class="n">SpinLockRelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hctl</span><span class="o">-&gt;</span><span class="n">freeList</span><span class="p">[</span><span class="n">freelist_idx</span><span class="p">].</span><span class="n">mutex</span><span class="p">);</span>

				<span class="cm">/*
				 * better hope the caller is synchronizing access to this
				 * element, because someone else is going to reuse it the next
				 * time something is added to the table
				 */</span>
				<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">HASH_ENTER</span><span class="p">:</span>
		<span class="k">case</span> <span class="n">HASH_ENTER_NULL</span><span class="p">:</span>
			<span class="cm">/* Return existing element if found, else create one */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">);</span>

			<span class="cm">/* disallow inserts if frozen */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">frozen</span><span class="p">)</span>
				<span class="n">elog</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">"cannot insert into frozen hashtable </span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">"</span><span class="p">,</span>
					 <span class="n">hashp</span><span class="o">-&gt;</span><span class="n">tabname</span><span class="p">);</span>

			<span class="n">currBucket</span> <span class="o">=</span> <span class="n">get_hash_entry</span><span class="p">(</span><span class="n">hashp</span><span class="p">,</span> <span class="n">freelist_idx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currBucket</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="cm">/* out of memory */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">HASH_ENTER_NULL</span><span class="p">)</span>
					<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="cm">/* report a generic message */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">hashp</span><span class="o">-&gt;</span><span class="n">isshared</span><span class="p">)</span>
					<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
							<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_OUT_OF_MEMORY</span><span class="p">),</span>
							 <span class="n">errmsg</span><span class="p">(</span><span class="s">"out of shared memory"</span><span class="p">)));</span>
				<span class="k">else</span>
					<span class="n">ereport</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span>
							<span class="p">(</span><span class="n">errcode</span><span class="p">(</span><span class="n">ERRCODE_OUT_OF_MEMORY</span><span class="p">),</span>
							 <span class="n">errmsg</span><span class="p">(</span><span class="s">"out of memory"</span><span class="p">)));</span>
			<span class="p">}</span>

			<span class="cm">/* link into hashbucket chain */</span>
			<span class="o">*</span><span class="n">prevBucketPtr</span> <span class="o">=</span> <span class="n">currBucket</span><span class="p">;</span>
			<span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/* copy key into record */</span>
			<span class="n">currBucket</span><span class="o">-&gt;</span><span class="n">hashvalue</span> <span class="o">=</span> <span class="n">hashvalue</span><span class="p">;</span>
			<span class="n">hashp</span><span class="o">-&gt;</span><span class="n">keycopy</span><span class="p">(</span><span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">),</span> <span class="n">keyPtr</span><span class="p">,</span> <span class="n">keysize</span><span class="p">);</span>

			<span class="cm">/*
			 * Caller is expected to fill the data field on return.  DO NOT
			 * insert any code that could possibly throw error here, as doing
			 * so would leave the table entry incomplete and hence corrupt the
			 * caller's data structure.
			 */</span>

			<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">ELEMENTKEY</span><span class="p">(</span><span class="n">currBucket</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">elog</span><span class="p">(</span><span class="n">ERROR</span><span class="p">,</span> <span class="s">"unrecognized hash action code: %d"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">action</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>				<span class="cm">/* keep compiler quiet */</span>
<span class="p">}</span>
</code></pre></div></div> <ol> <li>遇到插入操作时, 决定是否扩容.</li> <li>由哈希值计算应该落入哪一个bucket.</li> </ol> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                  <span class="n">max</span> <span class="n">bucket</span>
<span class="o">|-------------|-----|---------|</span>
          <span class="n">low</span> <span class="n">mask</span><span class="p">.</span>      <span class="n">high</span> <span class="n">mask</span>
</code></pre></div></div> <p>根据max bucket计算出一个二次幂对齐的low mask. high mask是 low mask的两倍. 给定哈希值h, 计算 h bit or high_mask, 计算结果一定在0 - high_mask之间. 如果计算结果小于max_bucket, 则计算结果就是bucket的编号, 否则说明计算结果处于max_bucket - high_mask之间, 此时需要将计算结果和 low_mask做位与, 将bucket偏移到0 - low_mask之间.</p> <ol> <li>根据bucket编号找到对应的bucket, 如果分段, 则需要在分段中寻找bucket</li> <li>find, enter, remove操作都需要首先遍历bucket, 尝试寻找对应的key <ul> <li>find: 找到返回entry, 找不到返回nul</li> <li>enter: 找到返回entry, 找不到从freelist分配entry, 插入bucket链表</li> <li>remove: 找到从bucket链表删除entry, 放回对应的freelist.</li> </ul> </li> </ol>]]></content><author><name></name></author><category term="PG"/><category term="Hash,"/><category term="PT-BM"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">匿名映射Mmap在多进程共享下的行为分析</title><link href="https://flayhhh.github.io/blog/2023/Anonymous-Mmap/" rel="alternate" type="text/html" title="匿名映射Mmap在多进程共享下的行为分析"/><published>2023-06-26T15:30:00+00:00</published><updated>2023-06-26T15:30:00+00:00</updated><id>https://flayhhh.github.io/blog/2023/Anonymous-Mmap</id><content type="html" xml:base="https://flayhhh.github.io/blog/2023/Anonymous-Mmap/"><![CDATA[<h2 id="本文背景">本文背景</h2> <p>在PT-BM项目中, 我们需要借助操作系统页表实现数据库系统的Buffer Table. 我们选择了基于PostgreSQL实现一个原型系统. 然而PG使用多进程工作模式, 而通常情况下, 进程之间是不共享页表的, 所以我们无法将原本buffer descriptor中的元信息(如dirty位, 引用计数…)放在单个进程的页表项中.</p> <p>然而, 我们目前还不确定在共享模式地匿名映射Mmap下, 不同进程的页表之间是否会以某种方式同步. 无论结果如何, 本文将对共享模式下的匿名映射Mmap进行探究.</p> <h2 id="example">Example</h2> <pre><code class="language-C++">#include &lt;sys/mman.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt; 
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int main() {
    const char* message = "Hello from parent!";

    // Use mmap to create shared memory
    void* addr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);
    if (addr == MAP_FAILED) {
        std::cerr &lt;&lt; "mmap failed" &lt;&lt; std::endl;
        return 1;
    }

    pid_t pid = fork();
    if (pid &lt; 0) {
        std::cerr &lt;&lt; "fork failed" &lt;&lt; std::endl;
        return 1;
    }

    if (pid == 0) {
        // Child process
        sleep(1); // Ensure parent gets a chance to write first

        // Read the message from the shared memory
        std::cout &lt;&lt; "Child received: " &lt;&lt; static_cast&lt;char*&gt;(addr) &lt;&lt; std::endl;
    } else {
        // Parent process
        // Write the message to the shared memory
        memcpy(addr, message, strlen(message) + 1);

        // Wait for the child process to finish
        int status;
        waitpid(pid, &amp;status, 0);
    }

    // Clean up
    if (munmap(addr, 4096) == -1) {
        std::cerr &lt;&lt; "munmap failed" &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}

</code></pre> <p>首先通过这个简单的例子阐述一下我们需要探索的问题. 父子进程通过Mmap(MAP_SHARED\MAP_ANON)建立了一段共享内存. 在这里MAP_SHARED指的是对共享内存的操作父子进程都可见. MAP_ANON的意思是简历匿名映射, 没有任何文件后备. 这里给出这两个标记位的具体定义作为参考.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       MAP_SHARED
              Share this mapping.  Updates to the mapping are visible to
              other processes mapping the same region, and (in the case
              of file-backed mappings) are carried through to the
              underlying file.  (To precisely control when updates are
              carried through to the underlying file requires the use of
              msync(2).)

       MAP_ANON
              Synonym for MAP_ANONYMOUS; provided for compatibility with
              other implementations.

       MAP_ANONYMOUS
              The mapping is not backed by any file; its contents are
              initialized to zero.  The fd argument is ignored; however,
              some implementations require fd to be -1 if MAP_ANONYMOUS
              (or MAP_ANON) is specified, and portable applications
              should ensure this.  The offset argument should be zero.
              Support for MAP_ANONYMOUS in conjunction with MAP_SHARED
              was added in Linux 2.4.
</code></pre></div></div> <p>在上面的程序中, 父进程mmap完之后就调用fork(). 这时由于lazy/on-demand机制的存在, 假设共享内存区域的虚拟地址并不对应实际的物理页. 只有在任意进程第一次使用该页面时, kernel才会为其分配物理内存. 因此在fork()返回的时间点. 父进程和子进程拥有两份独立的页表, 并且在他们的页表中, 虚拟地址‘addr’都没有对应实际的物理页. 下面分步骤讨论使用共享内存区域时, kernel的行为.</p> <ol> <li>在父进程第一次使用’addr’时, 触发缺页异常.</li> <li>kernel发现addr属于共享内存区vma, 于是使用对应的page fault handle.</li> <li>在page fault handle中, kernel发现这是第一次使用该页面, 于是为其分配物理内存.</li> <li>子进程使用’addr’时也会触发缺页异常, 因为子进程的页表独立于父进程的页表.</li> <li>在page fault handle中, kernel发现addr已经有对应的物理页, 于是在子进程的页表中建立映射.</li> </ol> <p>以上就是mmap(MAP_SHARED\MAP_ANON)的大致行为. 有一些存疑的地方还需要进一步分析. 例如, Step 5中, kernel使用什么数据结构查找共享区域的某个addr是否已经有对应的物理页.</p>]]></content><author><name></name></author><category term="OS"/><category term="PT-BM,"/><category term="mmap"/><summary type="html"><![CDATA[本文背景 在PT-BM项目中, 我们需要借助操作系统页表实现数据库系统的Buffer Table. 我们选择了基于PostgreSQL实现一个原型系统. 然而PG使用多进程工作模式, 而通常情况下, 进程之间是不共享页表的, 所以我们无法将原本buffer descriptor中的元信息(如dirty位, 引用计数…)放在单个进程的页表项中.]]></summary></entry><entry><title type="html">Source Code Anylysis of Mysql Index Interface</title><link href="https://flayhhh.github.io/blog/2022/MySQL-index-interface/" rel="alternate" type="text/html" title="Source Code Anylysis of Mysql Index Interface"/><published>2022-10-02T03:59:00+00:00</published><updated>2022-10-02T03:59:00+00:00</updated><id>https://flayhhh.github.io/blog/2022/MySQL-index-interface</id><content type="html" xml:base="https://flayhhh.github.io/blog/2022/MySQL-index-interface/"><![CDATA[<h2 id="1-索引创建">1. 索引创建</h2> <p>MySQL创建索引的方式有两种：</p> <ul> <li>在create table时创建</li> <li>调用create index创建索引</li> </ul> <p>因此与索引创建对应的存储引擎接口为：</p> <ul> <li>handle::create()</li> <li></li> </ul> <p>索引创建示例</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CREATE</span> <span class="n">TABLE</span> <span class="nf">Customer</span><span class="p">(</span>
<span class="n">ID</span> <span class="n">INT</span> <span class="n">NOT</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="n">LastName</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="n">NOT</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="n">FirstName</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="n">NOT</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="n">Email</span> <span class="n">CHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="n">NOT</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="n">INDEX</span> <span class="p">(</span><span class="n">Email</span><span class="p">),</span>
<span class="n">PRIMARY</span> <span class="n">KEY</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div> <h3 id="create-table时关于索引的信息">create table时,关于索引的信息</h3> <p>TABLE::key_info[]</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <p>TABLE_SHARE::primary_key</p> <p>TABLE_SHARE中包含了主键的索引序号</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">901</span>    <span class="cm">/* Primary key index number, used in TABLE::key_info[] */</span>
   <span class="mi">1</span>   <span class="n">uint</span> <span class="n">primary_key</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</code></pre></div></div> <h2 id="2-索引使用">2. 索引使用</h2> <p>通常，索引的使用方式分为两种：点查询和范围查询。为了更好的分析索引的行为和工作流程，我们先从应用层的视角列举一些典型的索引使用场景。</p> <p><strong>使用点查询的SQL语句：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">## where clause中的条件包含索引键的相等判断
</span>
<span class="o">&gt;</span> <span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">table_a</span> \
<span class="o">&gt;</span> <span class="n">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="o">&gt;</span> <span class="n">update</span> <span class="n">table_a</span> \
<span class="o">&gt;</span> <span class="n">set</span> <span class="n">name</span> <span class="o">=</span> <span class="err">'</span><span class="n">foo</span><span class="err">'</span> \
<span class="o">&gt;</span> <span class="n">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div> <p><strong>使用范围查询的SQL语句：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">## where clause中的条件是索引键的范围判断
</span>
<span class="o">&gt;</span> <span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">table_a</span> \
<span class="o">&gt;</span> <span class="n">where</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">...</span>
</code></pre></div></div> <h2 id="3-存储引擎的索引接口">3. 存储引擎的索引接口</h2> <p>索引与数据存储息息相关，所以索引由存储引擎实现。存储引擎需要提供索引接口供Server层使用。</p> <p>存储引擎当中索引相关的接口为：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">## 基类handler当中索引相关的接口
</span><span class="n">ha_index_init</span><span class="p">()</span>
<span class="n">ha_index_end</span><span class="p">()</span>
<span class="n">ha_read_range_first</span><span class="p">()</span>
<span class="o">|-</span> <span class="n">read_range_first</span><span class="p">()</span>
<span class="n">ha_read_range_next</span><span class="p">()</span>
<span class="o">|-</span> <span class="n">read_range_next</span><span class="p">()</span>
<span class="n">ha_index_read_map</span><span class="p">()</span>
<span class="n">ha_index_read_last_map</span><span class="p">()</span>
<span class="n">ha_index_read_idx_map</span><span class="p">()</span>
<span class="n">ha_index_next</span><span class="p">()</span>
<span class="n">ha_index_prev</span><span class="p">()</span>
<span class="n">ha_index_first</span><span class="p">()</span>
<span class="n">ha_index_last</span><span class="p">()</span>
<span class="n">ha_index_next_same</span><span class="p">()</span>
<span class="n">ha_index_or_rnd_end</span><span class="p">()</span>

<span class="cp">## 子类需要具体实现的索引接口（handler中索引相关的虚函数）
</span><span class="n">index_read_map</span><span class="p">()</span>
<span class="n">index_read</span><span class="p">()</span>
<span class="n">index_read_last_map</span><span class="p">()</span>
<span class="n">index_read_last</span><span class="p">()</span>
<span class="n">index_read_idx_map</span><span class="p">()</span>
<span class="n">index_next</span><span class="p">()</span>
<span class="n">index_prev</span><span class="p">()</span>
<span class="n">index_first</span><span class="p">()</span>
<span class="n">index_last</span><span class="p">()</span>
<span class="n">index_next_same</span><span class="p">()</span>
<span class="n">read_range_first</span><span class="p">()</span>
<span class="n">read_range_next</span><span class="p">()</span>
</code></pre></div></div> <h3 id="31-基类handler中高层次抽象的索引接口">3.1. 基类handler中高层次抽象的索引接口.</h3> <p>先具体分析基类handler中实现的索引相关接口.</p> <h3 id="311-ha_index_init">3.1.1. ha_index_init</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  Initialize use of index.

  @param idx     Index to use
  @param sorted  Use sorted order

  @return Operation status
    @retval 0     Success
    @retval != 0  Error (error code returned)
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_init</span><span class="p">(</span><span class="n">uint</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">result</span> <span class="o">=</span> <span class="n">index_init</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sorted</span><span class="p">)))</span> <span class="n">inited</span> <span class="o">=</span> <span class="n">INDEX</span><span class="p">;</span>
  <span class="n">end_range</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>可以看到ha_index_init主要将索引的初始化工作交给了子类的index_init.除此之外, ha_index_init设置了两个状态变量:</p> <ul> <li>inited</li> </ul> <p>见Appendix C.1, 表示table的使用方式.</p> <ul> <li>end_range</li> </ul> <p>见Appendix C.2, 表示范围查询的边界.</p> <h3 id="312-ha_index_end">3.1.2. ha_index_end</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  End use of index.

  @return Operation status
    @retval 0     Success
    @retval != 0  Error (error code returned)
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_end</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">inited</span> <span class="o">=</span> <span class="n">NONE</span><span class="p">;</span>
  <span class="n">end_range</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="n">m_record_buffer</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">m_unique</span><span class="p">)</span> <span class="n">m_unique</span><span class="o">-&gt;</span><span class="n">reset</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">index_end</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>ha_index_end()在调用index_end()之前做了一些额外工作:</p> <ul> <li>将inited设置为NONE</li> <li>将end_range设置为nullptr</li> <li>将m_record_buffer设置为nullptr</li> </ul> <p>见Appendix C.3, m_record_buffer是用于存放读取结果的缓存.</p> <ul> <li>重置m_unique</li> </ul> <p>见Appendix C.4, m_unique用于检测集合中的重复值.</p> <h3 id="313-ha_read_range_first">3.1.3. ha_read_range_first</h3> <p>ha_read_range_first()给定start key和 end key, 读取范围内的第一个row, 并设置好范围的终点, 供后续的ha_read_range_next()使用.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_read_range_first</span><span class="p">(</span><span class="k">const</span> <span class="n">key_range</span> <span class="o">*</span><span class="n">start_key</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">key_range</span> <span class="o">*</span><span class="n">end_key</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eq_range</span><span class="p">,</span>
                                 <span class="kt">bool</span> <span class="n">sorted</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">read_range_first</span><span class="p">(</span><span class="n">start_key</span><span class="p">,</span> <span class="n">end_key</span><span class="p">,</span> <span class="n">eq_range</span><span class="p">,</span> <span class="n">sorted</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>ha_read_range_first()的主要工作由read_range_first()完成:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @brief
  Read first row between two ranges.
  Store ranges for future calls to read_range_next.

  @param start_key		Start key. Is 0 if no min range
  @param end_key		End key.  Is 0 if no max range
  @param eq_range_arg	        Set to 1 if start_key == end_key
  @param sorted		Set to 1 if result should be sorted per key

  @note
    Record is read into table-&gt;record[0]

  @retval
    0			Found row
  @retval
    HA_ERR_END_OF_FILE	No rows in range
*/</span>
<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">read_range_first</span><span class="p">(</span><span class="k">const</span> <span class="n">key_range</span> <span class="o">*</span><span class="n">start_key</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">key_range</span> <span class="o">*</span><span class="n">end_key</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">eq_range_arg</span><span class="p">,</span>
                              <span class="kt">bool</span> <span class="n">sorted</span> <span class="nf">MY_ATTRIBUTE</span><span class="p">((</span><span class="n">unused</span><span class="p">)))</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">eq_range</span> <span class="o">=</span> <span class="n">eq_range_arg</span><span class="p">;</span>
  <span class="n">set_end_range</span><span class="p">(</span><span class="n">end_key</span><span class="p">,</span> <span class="n">RANGE_SCAN_ASC</span><span class="p">);</span>

  <span class="n">range_key_part</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">key_info</span><span class="p">[</span><span class="n">active_index</span><span class="p">].</span><span class="n">key_part</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">start_key</span><span class="p">)</span>  <span class="c1">// Read first record</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ha_index_first</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="k">else</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ha_index_read_map</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start_key</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
                               <span class="n">start_key</span><span class="o">-&gt;</span><span class="n">keypart_map</span><span class="p">,</span> <span class="n">start_key</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">HA_ERR_KEY_NOT_FOUND</span><span class="p">)</span> <span class="o">?</span> <span class="n">HA_ERR_END_OF_FILE</span> <span class="o">:</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">compare_key</span><span class="p">(</span><span class="n">end_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*
      The last read row does not fall in the range. So request
      storage engine to release row lock if possible.
    */</span>
    <span class="n">unlock_row</span><span class="p">();</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">HA_ERR_END_OF_FILE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>read_range_first()函数读取了范围查询当中的第一行.</p> <p>具体实现中有一些值得注意的点:</p> <ul> <li>eq_range的设置, 见Appendix C.5</li> </ul> <p>eq_range为true时,表示范围内的所有key都必须相等.</p> <ul> <li>set_end_range(end_key, RANGE_SCAN_ASC); 见Appendix C.2</li> </ul> <p>将end_key的信息和搜索方向记录到handler中.</p> <ul> <li>ha_index_first()读取索引顺序为1的行.</li> <li>ha_index_read_map()根据key进行索引搜索,这里根据start key找到第一条符合start key的记录.</li> </ul> <h3 id="314-ha_read_range_next">3.1.4. ha_read_range_next</h3> <p>server层进行范围查询时,使用ha_read_range_first定位起始key, 随后, handler中应该维护着索引当前指向的key以及对应的记录.ha_read_range_next()读取范围搜索中的下一条记录. 主要工作由read_range_next()函数完成.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_read_range_next</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">read_range_next</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** @brief
  Read next row between two endpoints.

  @note
    Record is read into table-&gt;record[0]

  @retval
    0			Found row
  @retval
    HA_ERR_END_OF_FILE	No rows in range
*/</span>
<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">read_range_next</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">DBUG_TRACE</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">eq_range</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* We trust that index_next_same always gives a row in range */</span>
    <span class="n">result</span> <span class="o">=</span>
        <span class="n">ha_index_next_same</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_range</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">end_range</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">ha_index_next</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">record</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">compare_key</span><span class="p">(</span><span class="n">end_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/*
        The last read row does not fall in the range. So request
        storage engine to release row lock if possible.
      */</span>
      <span class="n">unlock_row</span><span class="p">();</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">HA_ERR_END_OF_FILE</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="315-ha_index_read_map">3.1.5. ha_index_read_map</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  Read [part of] row via [part of] index.
  @param[out] buf          buffer where store the data
  @param      key          Key to search for
  @param      keypart_map  Which part of key to use
  @param      find_flag    Direction/condition on key usage

  @returns Operation status
    @retval  0                   Success (found a record, and function has
                                 set table status to "has row")
    @retval  HA_ERR_END_OF_FILE  Row not found (function has set table status
                                 to "no row"). End of index passed.
    @retval  HA_ERR_KEY_NOT_FOUND Row not found (function has set table status
                                 to "no row"). Index cursor positioned.
    @retval  != 0                Error

  @note Positions an index cursor to the index specified in the handle.
  Fetches the row if available. If the key value is null,
  begin at the first key of the index.
  ha_index_read_map can be restarted without calling index_end on the previous
  index scan and without calling ha_index_init. In this case the
  ha_index_read_map is on the same index as the previous ha_index_scan.
  This is particularly used in conjunction with multi read ranges.
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_read_map</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                               <span class="n">key_part_map</span> <span class="n">keypart_map</span><span class="p">,</span>
                               <span class="k">enum</span> <span class="n">ha_rkey_function</span> <span class="n">find_flag</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MYSQL_TABLE_IO_WAIT</span><span class="p">(</span><span class="n">PSI_TABLE_FETCH_ROW</span><span class="p">,</span> <span class="n">active_index</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">index_read_map</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keypart_map</span><span class="p">,</span> <span class="n">find_flag</span><span class="p">);</span>
  <span class="p">})</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>ha_index_read_map的语义是根据key进行索引搜索,读取结果存放到buf中.</p> <p><strong>key_part_map类型</strong></p> <p>key_part_map的类型为unsigned long。</p> <p>key_part_map是指，‘key中的列’与‘该列是否参与索引的搜索’之间的映射。例如我的索引key由四个column组成，按照这些索引列在schema中的顺序列举：key_part_a, key_part_b, key_part_c, key_part_d。对应的key_part_map实际上只需要四个bit，我们将key_part_map中低位的bit对应到schema中考前的column，key_part_map中bit为1时，说明该索引列参与索引。这样，key_part_map为1111就说明所有的索引列都参与索引。而0011则说明采用只采用key_part_a和key_part_b进行索引，即key_part_a和key_part_b组成的前缀索引。</p> <p><strong>enum ha_rkey_function类型</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">ha_rkey_function</span>
<span class="n">type</span> <span class="o">=</span> <span class="k">enum</span> <span class="n">ha_rkey_function</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span><span class="n">HA_READ_KEY_EXACT</span><span class="p">,</span> <span class="n">HA_READ_KEY_OR_NEXT</span><span class="p">,</span> <span class="n">HA_READ_KEY_OR_PREV</span><span class="p">,</span> <span class="n">HA_READ_AFTER_KEY</span><span class="p">,</span> <span class="n">HA_READ_BEFORE_KEY</span><span class="p">,</span> <span class="n">HA_READ_PREFIX</span><span class="p">,</span>
    <span class="n">HA_READ_PREFIX_LAST</span><span class="p">,</span> <span class="n">HA_READ_PREFIX_LAST_OR_PREV</span><span class="p">,</span> <span class="n">HA_READ_MBR_CONTAIN</span><span class="p">,</span> <span class="n">HA_READ_MBR_INTERSECT</span><span class="p">,</span> <span class="n">HA_READ_MBR_WITHIN</span><span class="p">,</span> <span class="n">HA_READ_MBR_DISJOINT</span><span class="p">,</span>
    <span class="n">HA_READ_MBR_EQUAL</span><span class="p">,</span> <span class="n">HA_READ_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
</code></pre></div></div> <h3 id="316-ha_index_read_last_map">3.1.6. ha_index_read_last_map</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">ha_index_read_last_map</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                             <span class="n">key_part_map</span> <span class="n">keypart_map</span><span class="p">);</span>

<span class="cp">## 具体实现随着存储引擎的不同而变化,在index_read_last_map中实现.
</span></code></pre></div></div> <p>ha_index_read_last_map的行为和ha_index_read_map类似.唯一的区别在于,该函数读取的符合条件的最后一条记录.</p> <h3 id="317-ha_index_read_idx_map">3.1.7. ha_index_read_idx_map</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  Initializes an index and read it.

  @see handler::ha_index_read_map.
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_read_idx_map</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">uint</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                                   <span class="n">key_part_map</span> <span class="n">keypart_map</span><span class="p">,</span>
                                   <span class="k">enum</span> <span class="n">ha_rkey_function</span> <span class="n">find_flag</span><span class="p">);</span>
</code></pre></div></div> <p>行为和ha_index_read_map类似,唯一的区别在于显式的指定使用的索引.</p> <h3 id="318-ha_index_next">3.1.8. ha_index_next</h3> <p>ha_index_next读取索引中的下一条记录.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  Reads the next row via index.

  @param[out] buf  Row data

  @return Operation status.
    @retval  0                   Success
    @retval  HA_ERR_END_OF_FILE  Row not found
    @retval  != 0                Error
*/</span>

<span class="kt">int</span> <span class="n">handler</span><span class="o">::</span><span class="n">ha_index_next</span><span class="p">(</span><span class="n">uchar</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MYSQL_TABLE_IO_WAIT</span><span class="p">(</span><span class="n">PSI_TABLE_FETCH_ROW</span><span class="p">,</span> <span class="n">active_index</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span>
                      <span class="p">{</span> <span class="n">result</span> <span class="o">=</span> <span class="n">index_next</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="p">})</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="319-ha_index_prev">3.1.9. ha_index_prev</h3> <p>读取索引中的前一条记录</p> <h3 id="3110-ha_index_first">3.1.10. ha_index_first</h3> <p>读取索引的第一条记录</p> <h3 id="3111-ha_index_last">3.1.11. ha_index_last</h3> <p>读取索引的最后一条记录</p> <h3 id="3112-ha_index_next_same">3.1.12. ha_index_next_same</h3> <p>读取下一条key相同的记录</p> <hr/> <h2 id="appendix-a-class-key">Appendix A: [class] KEY</h2> <p>index key的元数据 </p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">type</span> <span class="o">=</span> <span class="k">class</span> <span class="nc">KEY</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">uint</span> <span class="n">key_length</span><span class="p">;</span>
    <span class="n">ulong</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">ulong</span> <span class="n">actual_flags</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">user_defined_key_parts</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">actual_key_parts</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">unused_key_parts</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">usable_key_parts</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">block_size</span><span class="p">;</span>
    <span class="n">ha_key_alg</span> <span class="n">algorithm</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">is_algorithm_explicit</span><span class="p">;</span>
    <span class="n">plugin_ref</span> <span class="n">parser</span><span class="p">;</span>
    <span class="n">LEX_CSTRING</span> <span class="n">parser_name</span><span class="p">;</span>
    <span class="n">KEY_PART_INFO</span> <span class="o">*</span><span class="n">key_part</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="n">ulong</span> <span class="o">*</span><span class="n">rec_per_key</span><span class="p">;</span>
    <span class="n">LEX_CSTRING</span> <span class="n">engine_attribute</span><span class="p">;</span>
    <span class="n">LEX_CSTRING</span> <span class="n">secondary_engine_attribute</span><span class="p">;</span>
  <span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">m_in_memory_estimate</span><span class="p">;</span>
    <span class="n">rec_per_key_t</span> <span class="o">*</span><span class="n">rec_per_key_float</span><span class="p">;</span>
  <span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">is_visible</span><span class="p">;</span>
    <span class="n">TABLE</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>
    <span class="n">LEX_CSTRING</span> <span class="n">comment</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">is_functional_index</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">has_records_per_key</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">rec_per_key_t</span> <span class="n">records_per_key</span><span class="p">(</span><span class="n">uint</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">set_records_per_key</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="n">rec_per_key_t</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">supports_records_per_key</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">set_rec_per_key_array</span><span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">,</span> <span class="n">rec_per_key_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">in_memory_estimate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">set_in_memory_estimate</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="appendix-b-class-key_part_info">Appendix B: [class] KEY_PART_INFO</h2> <p>index key中每个key part的元数据</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">KEY_PART_INFO</span>
<span class="n">type</span> <span class="o">=</span> <span class="k">class</span> <span class="nc">KEY_PART_INFO</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">Field</span> <span class="o">*</span><span class="n">field</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">null_offset</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">store_length</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">fieldnr</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">key_part_flag</span><span class="p">;</span>
    <span class="n">uint8</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">uint8</span> <span class="n">null_bit</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">bin_cmp</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">init_from_field</span><span class="p">(</span><span class="n">Field</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">init_flags</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="appendix-c-class-handler当中索引相关的成员">Appendix C: [class] handler当中索引相关的成员</h2> <h3 id="1-inited">1. inited</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="p">{</span> <span class="n">NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">INDEX</span><span class="p">,</span> <span class="n">RND</span><span class="p">,</span> <span class="n">SAMPLING</span> <span class="p">}</span> <span class="n">inited</span><span class="p">;</span>
</code></pre></div></div> <p>[猜测]</p> <p>inited表示server层通过handler使用table的方式.</p> <p>例如当使用索引操作table时,inited的值为INDEX.</p> <h3 id="2-end_range">2. end_range</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
    End value for a range scan. If this is NULL the range scan has no
    end value. Should also be NULL when there is no ongoing range scan.
    Used by the read_range() functions and also evaluated by pushed
    index conditions.
  */</span>
  <span class="n">key_range</span> <span class="o">*</span><span class="n">end_range</span><span class="p">;</span>
</code></pre></div></div> <p>在范围查询时标记着结束的边界值.</p> <p>key_range的类型为:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">ptype</span> <span class="n">key_range</span>
<span class="n">type</span> <span class="o">=</span> <span class="k">struct</span> <span class="nc">key_range</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">key_part_map</span> <span class="n">keypart_map</span><span class="p">;</span>
    <span class="n">ha_rkey_function</span> <span class="n">flag</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">## 由于key中的组成部分可能不会全部使用,结束边界以及判定方法也依赖于调用时的情况,
## 所以需要key_range这一类型表达范围查询的边界.
</span></code></pre></div></div> <h3 id="3--m_record_buffer">3. m_record_buffer</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Record_buffer</span> <span class="o">*</span><span class="n">m_record_buffer</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">///&lt; Buffer for multi-row reads.</span>
</code></pre></div></div> <p>如注释所述,当server层通过handler读取table中的数据超过一行时,结果存放在m_record_buffer中.</p> <p>[class] Record_buffer见Appendix D.</p> <h3 id="4-m_unique">4. m_unique</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Filter row ids to weed out duplicates when multi-valued index is used */</span>
  <span class="n">Unique_on_insert</span> <span class="o">*</span><span class="n">m_unique</span><span class="p">;</span>
</code></pre></div></div> <p>[class] Unique_on_insert见 Appendix E.</p> <h3 id="5-eq_range">5. eq_range</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">eq_range</span>
</code></pre></div></div> <p>eq_range为true时,范围内的key值需要相等.</p> <h2 id="appendix-d-class-record_buffer">Appendix D: [class] Record_buffer</h2> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
  This class represents a buffer that can be used for multi-row reads. It is
  allocated by the executor and given to the storage engine through the
  handler, using handler::ha_set_record_buffer(), so that the storage engine
  can fill the buffer with multiple rows in a single read call.

  For now, the record buffer is only used internally by the storage engine as
  a prefetch cache. The storage engine fills the record buffer when the
  executor requests the first record, but it returns a single record only to
  the executor. If the executor wants to access the records in the buffer, it
  has to call a handler function such as handler::ha_index_next() or
  handler::ha_rnd_next(). Then the storage engine will copy the next record
  from the record buffer to the memory area specified in the arguments of the
  handler function, typically TABLE::record[0].
*/</span>
<span class="k">class</span> <span class="nc">Record_buffer</span> <span class="p">{</span>
  <span class="c1">/// The maximum number of records that can be stored in the buffer.</span>
  <span class="n">ha_rows</span> <span class="n">m_max_records</span><span class="p">;</span>
  <span class="c1">/// The number of bytes available for each record.</span>
  <span class="kt">size_t</span> <span class="n">m_record_size</span><span class="p">;</span>
  <span class="c1">/// The number of records currently stored in the buffer.</span>
  <span class="n">ha_rows</span> <span class="n">m_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">/// The @c uchar buffer that holds the records.</span>
  <span class="n">uchar</span> <span class="o">*</span><span class="n">m_buffer</span><span class="p">;</span>
  <span class="c1">/// Tells if end-of-range was found while filling the buffer.</span>
  <span class="kt">bool</span> <span class="n">m_out_of_range</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

 <span class="nl">public:</span>
  <span class="cm">/**
    Create a new record buffer with the specified size.

    @param records      the number of records that can be stored in the buffer
    @param record_size  the size of each record
    @param buffer       the @c uchar buffer that will hold the records (its
                        size should be at least
                        `Record_buffer::buffer_size(records, record_size)`)
  */</span>
  <span class="n">Record_buffer</span><span class="p">(</span><span class="n">ha_rows</span> <span class="n">records</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">record_size</span><span class="p">,</span> <span class="n">uchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">m_max_records</span><span class="p">(</span><span class="n">records</span><span class="p">),</span> <span class="n">m_record_size</span><span class="p">(</span><span class="n">record_size</span><span class="p">),</span> <span class="n">m_buffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{}</span>

  <span class="cm">/**
    This function calculates how big the @c uchar buffer provided to
    Record_buffer's constructor must be, given a number of records and
    the record size.

    @param records      the maximum number of records in the buffer
    @param record_size  the size of each record
    @return the total number of bytes needed for all the records
  */</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="nf">buffer_size</span><span class="p">(</span><span class="n">ha_rows</span> <span class="n">records</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">record_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">records</span> <span class="o">*</span> <span class="n">record_size</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**
    Get the number of records that can be stored in the buffer.
    @return the maximum number of records in the buffer
  */</span>
  <span class="n">ha_rows</span> <span class="n">max_records</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_max_records</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Get the amount of space allocated for each record in the buffer.
    @return the record size
  */</span>
  <span class="kt">size_t</span> <span class="n">record_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_record_size</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Get the number of records currently stored in the buffer.
    @return the number of records stored in the buffer
  */</span>
  <span class="n">ha_rows</span> <span class="n">records</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_count</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Get the buffer that holds the record on position @a pos.
    @param pos the record number (must be smaller than records())
    @return the @c uchar buffer that holds the specified record
  */</span>
  <span class="n">uchar</span> <span class="o">*</span><span class="nf">record</span><span class="p">(</span><span class="n">ha_rows</span> <span class="n">pos</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">max_records</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">m_buffer</span> <span class="o">+</span> <span class="n">m_record_size</span> <span class="o">*</span> <span class="n">pos</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**
    Add a new record at the end of the buffer.
    @return the @c uchar buffer of the added record
  */</span>
  <span class="n">uchar</span> <span class="o">*</span><span class="nf">add_record</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m_count</span> <span class="o">&lt;</span> <span class="n">max_records</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">record</span><span class="p">(</span><span class="n">m_count</span><span class="o">++</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**
    Remove the record that was last added to the buffer.
  */</span>
  <span class="kt">void</span> <span class="nf">remove_last</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">m_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="o">--</span><span class="n">m_count</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**
    Clear the buffer. Remove all the records. The end-of-range flag is
    preserved.
  */</span>
  <span class="kt">void</span> <span class="nf">clear</span><span class="p">()</span> <span class="p">{</span> <span class="n">m_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Reset the buffer. Remove all records and clear the end-of-range flag.
  */</span>
  <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">m_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">set_out_of_range</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**
    Set whether the end of the range was reached while filling the buffer.
    @param val true if end of range was reached, false if still within range
  */</span>
  <span class="kt">void</span> <span class="nf">set_out_of_range</span><span class="p">(</span><span class="kt">bool</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_out_of_range</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Check if the end of the range was reached while filling the buffer.
    @retval true if the end range was reached
    @retval false if the scan is still within the range
  */</span>
  <span class="kt">bool</span> <span class="n">is_out_of_range</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_out_of_range</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="appendix-e-class-unique_on_insert">Appendix E: [Class] Unique_on_insert</h2> <p>简单地概括,Unique_on_insert是一个检测集合中是否存在重复值的过滤器.</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">## 与Unique_on_insert一同定义的还有Class Unique,这里也一并看一下Unique的定义.
</span>
<span class="cm">/**
   Unique -- class for unique (removing of duplicates).
   Puts all values to the TREE. If the tree becomes too big,
   it's dumped to the file. User can request sorted values, or
   just iterate through them. In the last case tree merging is performed in
   memory simultaneously with iteration, so it should be ~2-3x faster.

   Unique values can be read only from final result (not on insert) because
   duplicate values can be contained in different dumped tree files.
*/</span>

<span class="k">class</span> <span class="nc">Unique</span> <span class="p">{</span>
  <span class="c1">/// Array of file pointers</span>
  <span class="n">Prealloced_array</span><span class="o">&lt;</span><span class="n">Merge_chunk</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">file_ptrs</span><span class="p">;</span>
  <span class="c1">/// Max elements in memory buffer</span>
  <span class="n">ulong</span> <span class="n">max_elements</span><span class="p">;</span>
  <span class="c1">/// Memory buffer size</span>
  <span class="n">ulonglong</span> <span class="n">max_in_memory_size</span><span class="p">;</span>
  <span class="c1">/// Cache file for unique values retrieval fo table read AM in executor</span>
  <span class="n">IO_CACHE</span> <span class="n">file</span><span class="p">;</span>
  <span class="c1">/// Tree to filter duplicates in memory</span>
  <span class="n">TREE</span> <span class="n">tree</span><span class="p">;</span>
  <span class="n">uchar</span> <span class="o">*</span><span class="n">record_pointers</span><span class="p">;</span>
  <span class="c1">/// Flush tree to disk</span>
  <span class="kt">bool</span> <span class="n">flush</span><span class="p">();</span>
  <span class="c1">/// Element size</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>

 <span class="nl">public:</span>
  <span class="n">ulong</span> <span class="n">elements</span><span class="p">;</span>
  <span class="n">Unique</span><span class="p">(</span><span class="n">qsort2_cmp</span> <span class="n">comp_func</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">comp_func_fixed_arg</span><span class="p">,</span> <span class="n">uint</span> <span class="n">size_arg</span><span class="p">,</span>
         <span class="n">ulonglong</span> <span class="n">max_in_memory_size_arg</span><span class="p">);</span>
  <span class="o">~</span><span class="n">Unique</span><span class="p">();</span>
  <span class="n">ulong</span> <span class="n">elements_in_tree</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">tree</span><span class="p">.</span><span class="n">elements_in_tree</span><span class="p">;</span> <span class="p">}</span>

  <span class="cm">/**
    Add new value to Unique

    @details The value is inserted either to the tree, or to the duplicate
    weedout table, depending on the mode of operation. If tree's mem buffer is
    full, it's flushed to the disk.

    @param ptr  pointer to the binary string to insert

    @returns
      false  error or duplicate
      true   the value was inserted
  */</span>
  <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">unique_add</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DBUG_TRACE</span><span class="p">;</span>
    <span class="n">DBUG_PRINT</span><span class="p">(</span><span class="s">"info"</span><span class="p">,</span> <span class="p">(</span><span class="s">"tree %u - %lu"</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">elements_in_tree</span><span class="p">,</span> <span class="n">max_elements</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">elements_in_tree</span> <span class="o">&gt;</span> <span class="n">max_elements</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span><span class="p">())</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tree</span><span class="p">.</span><span class="n">custom_arg</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="nf">get</span><span class="p">(</span><span class="n">TABLE</span> <span class="o">*</span><span class="n">table</span><span class="p">);</span>

  <span class="k">typedef</span> <span class="n">Bounds_checked_array</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span> <span class="n">Imerge_cost_buf_type</span><span class="p">;</span>

  <span class="k">static</span> <span class="kt">double</span> <span class="nf">get_use_cost</span><span class="p">(</span><span class="n">Imerge_cost_buf_type</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">uint</span> <span class="n">nkeys</span><span class="p">,</span>
                             <span class="n">uint</span> <span class="n">key_size</span><span class="p">,</span> <span class="n">ulonglong</span> <span class="n">max_in_memory_size</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">Cost_model_table</span> <span class="o">*</span><span class="n">cost_model</span><span class="p">);</span>

  <span class="c1">// Returns the number of elements needed in Imerge_cost_buf_type.</span>
  <span class="kr">inline</span> <span class="k">static</span> <span class="kt">size_t</span> <span class="nf">get_cost_calc_buff_size</span><span class="p">(</span><span class="n">ulong</span> <span class="n">nkeys</span><span class="p">,</span> <span class="n">uint</span> <span class="n">key_size</span><span class="p">,</span>
                                               <span class="n">ulonglong</span> <span class="n">max_in_memory_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ulonglong</span> <span class="n">max_elems_in_tree</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">max_in_memory_size</span> <span class="o">/</span> <span class="n">ALIGN_SIZE</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TREE_ELEMENT</span><span class="p">)</span> <span class="o">+</span> <span class="n">key_size</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nkeys</span> <span class="o">/</span> <span class="n">max_elems_in_tree</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">reset</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">walk</span><span class="p">(</span><span class="n">tree_walk_action</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">walk_action_arg</span><span class="p">);</span>

  <span class="n">uint</span> <span class="n">get_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ulonglong</span> <span class="n">get_max_in_memory_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">max_in_memory_size</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">is_in_memory</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">friend</span> <span class="kt">int</span> <span class="nf">unique_write_to_file</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v_key</span><span class="p">,</span> <span class="n">element_count</span> <span class="n">count</span><span class="p">,</span>
                                  <span class="kt">void</span> <span class="o">*</span><span class="n">unique</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">int</span> <span class="nf">unique_write_to_ptrs</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">v_key</span><span class="p">,</span> <span class="n">element_count</span> <span class="n">count</span><span class="p">,</span>
                                  <span class="kt">void</span> <span class="o">*</span><span class="n">unique</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/**
  Unique_on_insert -- similar to above, but rejects duplicates on insert, not
  just on read of the final result.
  To achieve this values are inserted into mem tmp table which uses index to
  detect duplicate keys. When memory buffer is full, tmp table is dumped to a
  disk-based tmp table.
*/</span>

<span class="k">class</span> <span class="nc">Unique_on_insert</span> <span class="p">{</span>
  <span class="c1">/// Element size</span>
  <span class="n">uint</span> <span class="n">m_size</span><span class="p">;</span>
  <span class="c1">/// Duplicate weedout tmp table</span>
  <span class="n">TABLE</span> <span class="o">*</span><span class="n">m_table</span><span class="p">{</span><span class="nb">nullptr</span><span class="p">};</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Unique_on_insert</span><span class="p">(</span><span class="n">uint</span> <span class="n">size</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{}</span>
  <span class="cm">/**
    Add row id to the filter

    @param ptr pointer to the rowid

    @returns
      false  rowid successfully inserted
      true   duplicate or error
  */</span>
  <span class="kt">bool</span> <span class="nf">unique_add</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>

  <span class="cm">/**
    Initialize duplicate filter - allocate duplicate weedout tmp table

    @returns
      false initialization succeeded
      true  an error occur
  */</span>
  <span class="kt">bool</span> <span class="nf">init</span><span class="p">();</span>

  <span class="cm">/**
    Reset filter - drop all rowid records

    @param reinit  Whether to restart index scan
  */</span>
  <span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="kt">bool</span> <span class="n">reinit</span><span class="p">);</span>

  <span class="cm">/**
    Cleanup unique filter
  */</span>
  <span class="kt">void</span> <span class="nf">cleanup</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="DB"/><category term="Code-Analysis"/><summary type="html"><![CDATA[This is an old note, I put it here as blog testing purpose.]]></summary></entry></feed>